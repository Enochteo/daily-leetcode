## Decode Ways
**Understand**
You are given a string s containing digits. Each digit or pair of digits can map to letters:

'1' → 'A', '2' → 'B', ..., '26' → 'Z'.

You need to return the number of ways to decode the string.

**Match**
This is a Dynamic Programming problem.

Very similar to the Climbing Stairs pattern:

At every index, decide whether to take 1 digit or 2 digits (if valid).

Invalid cases like '0' need to be handled.

**Plan**
Use bottom-up dynamic programming.

Start from the back of the string, move toward the front.

dp[i] = number of ways to decode from index i to the end.

If current char is '0', dp[i] = 0

Otherwise, dp[i] = dp[i+1]

If the two-digit number starting at i is valid (<= 26), add dp[i+2]

Initialize dp[len(s)] = 1 (empty string base case)

Return dp[0]