## Reverse Linked List II
**Understand**
You're given the head of a singly linked list and two integers left and right. Reverse the nodes of the list from position left to position right, and return the modified list.

The positions are 1-indexed.

Only the sublist between left and right (inclusive) is reversed.

Do not use extra space for another list.

**Match**
This problem is a linked list reversal variant with bounded start and end positions. Classic features:

In-place modification.

Two-pointer traversal.

Requires maintaining connections before and after the reversed sublist.

Similar to:

Reverse entire linked list

Reverse K-group nodes in linked list

**Plan**
Use a dummy node before head to handle edge cases cleanly.

Traverse to the node just before left, saving that node as LeftPrev.

Reverse the sublist from left to right:

Use classic reversal technique with prev, current, and temp.

Connect:

LeftPrev.next to the head of reversed sublist.

Tail of reversed sublist (last) to current (node after right).

Return dummy.next as the new head.