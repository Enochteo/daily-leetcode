## Permutations
**Understand**
Return all possible permutations of a list of distinct integers.
The permutations would be of length n! where n is the length of the list.

**Match**
Problem Type: Backtracking / Divide and Conquer

Output: All permutations → full traversal of recursive tree

**Plan**

If nums is empty, return [[]].

Use a helper recurse(index):

If index == len(nums), append a copy of nums to results.

Otherwise, for each i from index to len(nums)-1:

Swap nums[i] with nums[index], recurse on index+1, then swap back.

Start with recurse(0) and return res.

**Implement**
```py
class Solution(object):
    def permute(self, nums):
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        """
        if not nums:
            return [[]]
        res = []
        def recurse(index):
            if index == len(nums):
                res.append(nums[:])
            for i in range(index, len(nums)):
                nums[i], nums[index] = nums[index], nums[i]
                recurse(index + 1)
                nums[i], nums[index] = nums[index], nums[i]
        recurse(0)
        return res
```

**Review**

Appends a shallow copy (nums[:]) at the leaf to avoid later mutations.

The swap/backtrack scheme ensures each element appears in each position across recursive levels without extra auxiliary structures.

Handles empty input by returning a single empty permutation.

**Evaluate**
Time Complexity: O(n · n!) — there are n! permutations and copying costs up to O(n) each.
Space Complexity: O(n) recursion depth (ignoring output), plus output size O(n · n!).

**Pattern to remember**
For generating permutations in place: for each position index, iterate i = index..n-1, swap nums[index]↔nums[i], recurse to index+1, then swap back to restore the array for the next choice.