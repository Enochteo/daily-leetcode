## Ones and Zeroes

**Understand**

We are given:

A list of binary strings strs.

Two integers m and n, representing the number of available zeros and ones.

We must find the maximum number of strings that can be formed using at most m zeros and n ones.

Example:

Input:
strs = ["10", "0001", "111001", "1", "0"], m = 5, n = 3  
Output: 4

Explanation:
Form the strings: "10", "0001", "1", and "0"  
They use 5 zeros and 3 ones in total.

Goal:
Select the largest subset of strs that fits within the (m, n) constraints.

**Match**

This is a 0/1 Knapsack problem with two capacity dimensions:

One dimension for zeros (m)

One dimension for ones (n)

Each string has a weight (zero_count, one_count) and value = 1.
We must maximize the number of strings chosen.

To solve efficiently:

Use DFS with memoization to explore “take or skip” choices.

Cache results to avoid recomputation of subproblems.

**Plan**

Preprocessing:

Convert each string into a tuple (zero_count, one_count) for fast access.

Recursive DFS Definition:

dfs(i, zeroes, ones) returns the max number of strings we can form using:

Remaining strings starting from index i

At most zeroes zeros and ones ones

Transition:

Option 1: Take the current string if it fits →
1 + dfs(i + 1, zeroes - cur_zeroes, ones - cur_ones)

Option 2: Skip the current string →
dfs(i + 1, zeroes, ones)

Return max(take, not_take)

Memoization:

Store results in cache[(i, zeroes, ones)] to avoid recomputation.

Base Case:

If i == len(strs), return 0 (no more strings left).

Return dfs(0, m, n) as the final result.

**Implement**

```py
class Solution:
    def findMaxForm(self, strs: List[str], m: int, n: int) -> int:
        for i in range(len(strs)):
            strs[i] = (strs[i].count('0'), strs[i].count('1'))

        cache = {}
        def dfs(i, zeroes, ones):

            if (i, zeroes, ones) in cache:
                return cache[(i, zeroes, ones)]
            if i == len(strs):
                return 0

            cur_zeroes, cur_ones = strs[i]
            take = float('-inf')

            if zeroes - cur_zeroes >= 0 and ones - cur_ones >= 0:
                take = 1 + dfs(i + 1, zeroes - cur_zeroes, ones - cur_ones)

            not_take = dfs(i + 1, zeroes, ones)
            cache[(i, zeroes, ones)] = max(take, not_take)
            return cache[(i, zeroes, ones)]

        return dfs(0, m, n)
```

**Review**

Correctness: Implements 0/1 knapsack logic with two constraints.
Efficiency: Uses memoization to reduce exponential recursion.
Readability: Structured recursion with clear transitions.
Edge-safe: Works even when strings have zero zeros or ones.

**Evaluate**
Metric Analysis
Time Complexity O(L × m × n) — L = number of strings
Space Complexity O(L × m × n) — for memoization storage
Approach DFS + Memoization (Top-Down DP)
Edge Cases Empty strs → 0; all strings too large → 0; m/n = 0 cases handled

**Pattern to Remember**

This follows the Multi-Dimensional 0/1 Knapsack Pattern:

Each item (string) has multiple “costs” (zeros, ones).

Use recursion + memoization or iterative DP (dp[m+1][n+1]) to track feasible combinations.
Commonly seen in subset selection problems with two or more resource limits.
