## Insert Interval

**Understand**

You are given a list of non-overlapping, sorted intervals and a newInterval.
Your task is to insert the new interval into the list so that the final list:

Remains sorted by start time

Has no overlapping intervals (all overlapping ones must be merged)

Example:

Input: intervals = [[1,3],[6,9]], newInterval = [2,5]
Output: [[1,5],[6,9]]

Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]
Output: [[1,2],[3,10],[12,16]]

Goal: Insert and merge correctly.

**Match**

This problem follows the Interval Insertion + Merge Pattern:

Insert the new interval at the correct sorted position

Merge all intervals using classic merging logic:

If overlapping, merge using:

[start, end] = [min(start1, start2), max(end1, end2)]

Else, append normally.

Many people do both steps in one pass, but your approach does them separately:

Step 1: Insert newInterval into correct position → produces stack.

Step 2: Run interval merge logic → produces new_stack.

This approach is fully valid.

**Plan**

Iterate over intervals:

When reaching the first interval where newInterval.start <= interval.start, insert newInterval.

Push all intervals into a stack.

Edge case: if newInterval was never inserted, append it at the end.

Edge case: empty input → return [newInterval].

Run a merging pass:

For each interval in stack, either merge with previous or append to new_stack.

Return the merged intervals.

**Implement**

```py
class Solution:
    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:
        stack = []
        ins_start, ins_end = newInterval
        inserted = False

        # Insert newInterval in sorted order
        for interval in intervals:
            if not inserted and interval[0] >= ins_start:
                stack.append(newInterval)
                inserted = True
            stack.append(interval)

        # If never inserted, append at end
        if len(stack) == len(intervals):
            stack.append(newInterval)

        # If no intervals originally
        if not intervals:
            stack = [newInterval]

        # Merge intervals
        new_stack = []
        for start, end in stack:
            if new_stack and new_stack[-1][1] >= start:
                prev_start, prev_end = new_stack.pop()
                new_stack.append([min(prev_start, start), max(prev_end, end)])
            else:
                new_stack.append([start, end])

        return new_stack
```

**Review**

Correct insertion (sorted by start time)
Correct merge (classic interval merging)
Handles edge cases: empty input, no overlap, full overlap
No unnecessary complexity

**Evaluate**
Metric Analysis
Time Complexity O(n) — single pass insert + single pass merge
Space Complexity O(n) — to store merged intervals
Approach Insert-then-merge interval pattern
Edge Cases Empty intervals, insertion at start/end, full overlap, no overlap

**Pattern to Remember**

This problem follows the Insert + Merge Interval Pattern widely used in scheduling, calendar merging, and timeline algorithms.
