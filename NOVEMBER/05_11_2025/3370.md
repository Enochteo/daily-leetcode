## Smallest Number with All 1-Bits ≥ n

**Understand**

You need to return the smallest integer x such that:

x is composed entirely of binary 1s (e.g., 1, 3 (11), 7 (111), 15 (1111), …),

and x ≥ n.

**Match**

This is a bit manipulation pattern question — it uses:

Bitwise shift << to build 111... progressively.

Bitwise OR | to test or build full bit masks.

You can solve this in two equivalent ways:

Iterative left-shift until n becomes 1 (build mask from low bits upward).

Bitwise OR masking until the constructed mask fully covers n.

**Plan** (Version 1 – Bit-Building Loop)

Initialize res = 1.

While n != 1:

Left shift res by 1 and add 1 → doubles the pattern and adds one more bit of 1.

Right shift n by 1 → effectively divides it by 2 (reduces number of bits).

Return res.

Example:

n = 5 (101)
res = 1 → 11 → 111 → done
return 7

**Implement**

```py
class Solution:
    def smallestNumber(self, n: int) -> int:
        res = 1
        while n != 1:
            res = (res << 1) + 1
            n >>= 1
        return res
```

**Plan** (Version 2 – Bitmask Construction)

Start with mask = 1.

While (n | mask) != mask:

Left shift and OR with 1 → (mask << 1) | 1 (adds another 1 bit).

Return mask.

The loop continues until the all-ones mask completely covers n.

Example:

n = 5 (101)
mask = 1 → 3 (11) → 7 (111)
n | mask = 7 == mask → stop
return 7

**Implement** (Version 2)

```py
class Solution:
    def smallestNumber(self, n: int) -> int:
        mask = 1
        while (n | mask) != mask:
            mask = (mask << 1) | 1
        return mask
```

**Review**

Uses only bit manipulation (no string/int conversions).
O(log n) time since each iteration reduces or adds one bit.
Space O(1).

**Evaluate**

Time Complexity: O(log n)

Space Complexity: O(1)

Works for any positive integer n ≥ 1.

**Pattern to Remember**

This is the Bitmask Expansion Pattern — constructing a full set of bits to cover a target number.
