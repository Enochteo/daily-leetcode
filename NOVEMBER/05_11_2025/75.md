## Sort Colors

**Understand**
Given an array nums with values 0, 1, or 2, sort it in-place so that all 0s come first, then 1s, then 2s — without using a built-in sort.
Example:
Input: nums = [2,0,2,1,1,0]
Output: [0,0,1,1,2,2]

You must solve it in O(n) time and O(1) extra space.

**Match**
This is a partitioning / in-place sorting problem — specifically the Dutch National Flag algorithm.
You use three pointers to track:

l: left boundary for 0s

r: right boundary for 2s

i: current scanning index

At each step:

If you see 0: swap with l, increment l.

If you see 2: swap with r, decrement r, and stay on i (since swapped value might be 0 or 1).

Otherwise (when 1), move i forward.

**Plan**

Initialize l = 0, r = len(nums) - 1, i = 0.

While i <= r:

If nums[i] == 0: swap with nums[l]; increment l and i.

If nums[i] == 2: swap with nums[r]; decrement r; don’t increment i.

Else: (nums[i] == 1) → just i += 1.

Continue until i > r.

**Implement**

```py
class Solution:
    def sortColors(self, nums: List[int]) -> None:
        l, r = 0, len(nums) - 1
        i = 0
        while i <= r:
            if nums[i] == 0:
                nums[i], nums[l] = nums[l], nums[i]
                l += 1
            elif nums[i] == 2:
                nums[i], nums[r] = nums[r], nums[i]
                r -= 1
                i -= 1  # stay to check swapped element
            i += 1
```

**Review**
In-place, no extra data structures
One-pass O(n) time complexity
Uses the Dutch National Flag principle (0s left, 2s right, 1s in the middle)
Efficiently handles any mix of values

**Evaluate**

Time Complexity: O(n)

Space Complexity: O(1)

Edge Cases:

All elements are the same → works fine

Single-element list → safe

Already sorted → minimal swaps

**Pattern to Remember**
This is the Dutch National Flag / Three-Way Partitioning Pattern, used in:

QuickSort partitioning

Sort Colors

Segregate 0s, 1s, 2s / Negative-Positive Numbers

Move Zeroes / Sort by Parity
