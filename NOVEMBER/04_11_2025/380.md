## Insert Delete GetRandom O(1)

**Understand**

Design a data structure that supports insert, delete, and getRandom in average O(1) time.

Required methods:

insert(val) → Inserts an item. Returns True if the item was not present, else False.

remove(val) → Removes an item. Returns True if the item was present, else False.

getRandom() → Returns a random element with equal probability.

**Match**

This is a data structure design problem requiring constant-time operations.

To achieve O(1):

Use a hash map (positions) to store the index of each element in a list.

Use a dynamic array (store) to support fast random access.

Key Idea:

On deletion, swap the element to remove with the last element, pop it, and update indices — avoids O(n) shifts.

getRandom() just returns a random index in the array.

**Plan**

Insert(val):

If already exists in positions, return False.

Append to store and record its index in positions.

Return True.

Remove(val):

If not in positions, return False.

Swap the target element with the last one in store.

Pop the last element.

Update indices in positions and delete removed value.

Return True.

getRandom():

Generate random index between 0 and len(store) - 1.

Return store[rand_index].

**Implement**

```py
import random

class RandomizedSet:

    def __init__(self):
        self.positions = {}   # val -> index
        self.store = []       # stores actual values
        self.index = 0        # keeps count

    def insert(self, val: int) -> bool:
        if val in self.positions:
            return False
        self.store.append(val)
        self.positions[val] = self.index
        self.index += 1
        return True

    def remove(self, val: int) -> bool:
        if val not in self.positions:
            return False
        index = self.positions[val]
        last_val = self.store[-1]
        last_index = self.positions[last_val]

        # Swap value with last, then pop
        self.store[index], self.store[last_index] = self.store[last_index], self.store[index]
        self.store.pop()
        self.index -= 1

        # Update moved element's index
        self.positions[last_val] = index
        del self.positions[val]
        return True

    def getRandom(self) -> int:
        rand_index = random.randint(0, len(self.store) - 1)
        return self.store[rand_index]
```

**Review**

O(1) average for all operations.
Uses array + hashmap dual structure.
Uniform random access via Python’s random.randint.
