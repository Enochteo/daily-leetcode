## Max Alternating Sum of Squared Symmetric Pairs

**Understand**

Given an integer list nums, the algorithm computes an alternating difference of squared terms using symmetric elements from both ends after sorting by absolute value.

The final result adds the square of right-side values and subtracts the square of left-side values, moving inward until the two pointers meet.
If one element remains (when l == r), its square is added.

Example:

Input: nums = [1, -3, 2, 4]
Sorted by abs: [1, 2, -3, 4]
Right: add 4² + (-3)² = 16 + 9
Left: subtract 1² + 2² = 1 + 4
Result: (16 + 9) - (1 + 4) = 20

**Match**

This resembles a two-pointer accumulation pattern, often used for problems where symmetric or opposing ends are processed simultaneously.

Key idea:

Sort array by absolute value.

Use left (l) and right (r) pointers.

At each step:

Add nums[r]²

Subtract nums[l]²

Move inward until l >= r.

**Plan**

Sort nums by absolute value (increasing).

Initialize pointers:

l = 0, r = len(nums) - 1

res = 0 (cumulative result).

While l < r:

Add right square → res += nums[r] \*\* 2

Subtract left square → res -= nums[l] \*\* 2

Move pointers inward (l += 1, r -= 1).

If a single center element remains (l == r), add its square.

Return res.

**Implement**

```py
class Solution:
    def maxAlternatingSum(self, nums: List[int]) -> int:
        nums.sort(key=abs)
        l, r = 0, len(nums) - 1
        res = 0
        while l < r:
            res += nums[r] ** 2
            res -= nums[l] ** 2
            l += 1
            r -= 1
        if r == l:
            res += nums[r] ** 2
        return res
```

**Review**

Uses O(n log n) sorting and O(n) two-pointer traversal.
Works symmetrically from both ends.
Performs all operations in-place with O(1) extra memory.
