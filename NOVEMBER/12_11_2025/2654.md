## Minimum Operations to Make All Array Elements Equal to 1

**Understand**

You are given an array nums.
In one operation, you can pick any two adjacent elements and replace one of them with their GCD.

Goal:
Make all elements equal to 1 using the minimum number of operations.

Key Observations:

If the array already contains a 1, you only need to convert the rest to 1.

Each non-1 element takes 1 operation.

Answer = nums.length - count(1)

If the array has no 1s, you must create one by taking the GCD of some subarray.

The smallest subarray whose GCD = 1 is crucial.

If no subarray has GCD = 1 → impossible, return -1.

After generating 1 using a subarray of length L, turning the entire array into 1 takes:

(L - 1) operations # to reduce that subarray to a single 1

- (n - 1) operations # convert remaining n-1 elements using adjacency

**Match**

Two phases:

Phase 1 – Check for existing ones
If found, we simply count the operations needed to convert others.

Phase 2 – Find minimal subarray with GCD = 1
This uses the classic subarray GCD shrinking pattern:

Expand window and maintain running GCD.

GCD always decreases or stays same.

Break early when GCD hits 1.

Use nested loops to find minimal length, which is accepted because GCD shrinks quickly and constraints are small.

**Plan**

Count how many 1s are already present.

If ones > 0, return n - ones.

Define helper gcd(a, b).

For every possible left index l:

Expand right index r and update cur_gcd.

When cur_gcd == 1, update minimum length and break.

If no subarray reduces to gcd=1, return -1.

5.Otherwise compute operations:

(min_len - 1) + (n - 1)

Implement
class Solution:
def minOperations(self, nums: List[int]) -> int: # if there are already ones
ones = nums.count(1)
if ones:
return len(nums) - ones

        # helper gcd
        def gcd(a, b):
            while a and b:
                a = a % b
                b, a = a, b
            return max(a, b)

        # find minimum subarray whose GCD = 1
        min_sub_arr_len = float('inf')

        for l in range(len(nums)):
            cur_gcd = 0
            for r in range(l, len(nums)):
                cur_gcd = gcd(cur_gcd, nums[r])
                if cur_gcd == 1:
                    min_sub_arr_len = min(min_sub_arr_len, r - l + 1)
                    break

        if min_sub_arr_len == float('inf'):
            return -1

        # Total operations:
        # (min_len - 1) to reduce subarray to single 1,
        # plus (n - 1) to propagate that 1 to all elements.
        return (min_sub_arr_len - 1) + len(nums) - 1

**Review**

✓ Correctly handles both cases (existing 1’s and no 1’s)
✓ Efficient enough due to GCD shrink property
✓ Uses early breaks to avoid unnecessary computation
✓ Matches editorial logic

**Evaluate**
Time Complexity O(n² \* log(max(nums))) but much faster in practice because GCD drops quickly
Space Complexity O(1)
Approach GCD scanning + minimal subarray search
Edge Cases - Single element array

- All elements equal but >1
- No possible GCD=1

**Pattern to Remember**

This problem uses the Subarray GCD Search Pattern:

Gradually shrink GCD by expanding window.

First window reaching GCD=1 gives best chance for minimal operations.
