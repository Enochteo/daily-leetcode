## Next Permutation

**Understand**

Given an integer array nums, rearrange its elements to form the next lexicographically greater permutation.
If no such permutation exists (array is in descending order), rearrange it into the lowest possible order (ascending).

Example 1:

Input: [1, 2, 3]
Output: [1, 3, 2]

Example 2:

Input: [3, 2, 1]
Output: [1, 2, 3]

Example 3:

Input: [1, 1, 5]
Output: [1, 5, 1]

Goal:
Transform the list in-place into the next greater permutation of numbers.

**Match**

This is a sequence manipulation and pattern reversal problem that follows the Pivot–Swap–Reverse logic:

Identify the pivot (first descending element from the right).

Swap it with the next greater element to its right.

Reverse the subarray to the right of the pivot to get the smallest possible suffix.

This is a standard next lexicographic permutation pattern, common in permutation-based algorithms.

**Plan**

Find the Pivot:

Starting from the end, find the first index i such that nums[i] > nums[i - 1].

That means nums[i - 1] is the pivot — the point where the next permutation must change.

If no such pivot exists (array is strictly decreasing), reverse the entire array and return.

Find Next Greater Element:

From the right end, find the smallest element larger than the pivot.

Swap it with the pivot.

Reverse the Suffix:

Reverse the elements to the right of the pivot index to make it the smallest possible sequence.

In-place Modification:

Modify the array directly; do not return anything.

**Implement**

```py
class Solution:
    def nextPermutation(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        pivot = -1

        # Find pivot
        for i in range(len(nums) - 1, 0, -1):
            if nums[i] > nums[i - 1]:
                pivot = i - 1
                break

        # If no pivot found → reverse entire array
        if pivot < 0:
            nums.reverse()
            return

        #  Find element just larger than pivot and swap
        for i in range(len(nums) - 1, pivot, -1):
            if nums[i] > nums[pivot]:
                nums[i], nums[pivot] = nums[pivot], nums[i]
                break

        #  Reverse the suffix
        nums[pivot + 1:] = reversed(nums[pivot + 1:])
```

**Review**

Finds the correct pivot efficiently from the end.
Handles descending (last permutation) case by reversing.
Reverses suffix to restore the smallest possible order after swap.
In-place, O(1) extra space.

**Evaluate**
Metric Analysis
Time Complexity O(N) — one pass to find pivot + one to find swap + one to reverse
Space Complexity O(1) — in-place manipulation
Approach Pivot–Swap–Reverse Pattern
Edge Cases [3,2,1] → [1,2,3], [1,5,1] → [5,1,1], single element → unchanged

**Pattern to Remember**

This problem follows the Next Lexicographic Permutation Pattern:

Identify the pivot (first descending element from right).

Swap with the smallest number larger than pivot to the right.

Reverse the suffix to get the next minimal permutation.
