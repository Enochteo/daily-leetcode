## Accounts Merge

**Understand**
We are given a list of accounts, each represented as:
[name, email1, email2, ...].
If two accounts share at least one email, they belong to the same person and must be merged into one account containing all unique emails (sorted lexicographically) under the same name.
Example:
Input:
[
["John", "johnsmith@mail.com", "john00@mail.com"],
["John", "johnnybravo@mail.com"],
["John", "johnsmith@mail.com", "john_newyork@mail.com"],
["Mary", "mary@mail.com"]
]

Output:
[
["John", "john00@mail.com", "john_newyork@mail.com", "johnsmith@mail.com"],
["John", "johnnybravo@mail.com"],
["Mary", "mary@mail.com"]
]

Goal:
Identify accounts that are connected (share at least one email) and merge them efficiently.

**Match**
This problem maps directly to a graph connectivity problem:

Each account is a node.

An edge exists between two nodes if they share an email address.

All connected nodes (accounts) represent the same person.

To efficiently identify these connected components:

Use Disjoint Set Union (Union-Find) to merge indices that belong to the same person.

Alternative approaches:

DFS/BFS graph traversal based on shared emails (less efficient for large datasets).

**Plan**

Initialize DSU for all accounts (each account is initially its own parent).

For each pair of accounts with the same name:

Check if they share any common email.

If they do, union(i, j) to merge their sets.

After all unions, group accounts by their root parent using a mapping dictionary.

For each group:

Collect all unique emails from the merged accounts.

Sort the emails lexicographically.

Prepend the account holder’s name.

Return the list of merged accounts.

**Implement**

```py
from collections import defaultdict
from typing import List

class DSU:
    def __init__(self, n):
        self.par = [i for i in range(n)]
        self.rank = [1 for _ in range(n)]

    def find(self, node):
        while node != self.par[node]:
            self.par[node] = self.par[self.par[node]]  # Path compression
            node = self.par[node]
        return node

    def union(self, a, b):
        pa, pb = self.find(a), self.find(b)
        if pa == pb:
            return False
        if self.rank[pa] > self.rank[pb]:
            self.par[pb] = pa
            self.rank[pa] += self.rank[pb]
        else:
            self.par[pa] = pb
            self.rank[pb] += self.rank[pa]
        return True


class Solution:
    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:
        dsu = DSU(len(accounts))

        # Step 1: Union accounts with same name and overlapping emails
        for i in range(len(accounts)):
            cur_acct = accounts[i]
            for j in range(i, len(accounts)):
                if accounts[j][0] == cur_acct[0]:
                    if set(accounts[j][1:]) & set(cur_acct[1:]):  # Shared email
                        dsu.union(i, j)

        # Step 2: Group accounts by parent
        mapping = defaultdict(list)
        for i in range(len(accounts)):
            parent = dsu.find(i)
            mapping[parent].append(i)

        # Step 3: Merge emails for each component
        res = []
        for p in mapping:
            emails = set()
            for idx in mapping[p]:
                emails.update(accounts[idx][1:])
            res.append([accounts[p][0]] + sorted(emails))
        return res
```

**Review**
Correctness: Handles multiple overlapping email chains and ensures unique, sorted email lists.
Clarity: Uses clear DSU structure with path compression and union by size.

Functionality: Works for all provided and edge cases (e.g., single account, no overlaps).
⚙ Optimization Note:
This implementation uses a nested loop (O(N² × M)) to check overlaps.
It can be optimized to O(N × M) by mapping each email to an account index and directly unioning accounts that share that email.

**Evaluate**
MetricCurrent SolutionOptimized ApproachTime ComplexityO(N² × M) — pairwise intersection checksO(N × M α(N)) using email-to-index mapSpace ComplexityO(N × M)O(N × M)ApproachDSU with intersection-based unionsDSU with email-to-index mappingAlternativeDFS/BFS via adjacency list

**Pattern to Remember**
This problem is a Union-Find / Connected Components pattern, often used when elements share indirect relationships.
Whenever entities need to be merged through shared identifiers (emails, names, IPs, etc.), DSU efficiently identifies all connected groups without redundant traversal.
