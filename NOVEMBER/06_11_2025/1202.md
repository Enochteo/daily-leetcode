## Smallest String With Swaps

**Understand**

We are given a string s and a list of index pairs where each pair [a, b] means the characters at indices a and b can be swapped. Since swaps can occur multiple times, all indices connected directly or indirectly through pairs form a connected component of interchangeable positions.

Our goal is to return the lexicographically smallest string achievable by swapping characters within each connected component any number of times.

Example:

Input: s = "dcab", pairs = [[0,3],[1,2]]
Output: "bacd"

Explanation:

Component 1: indices [0,3] → chars {d,b} → sorted {b,d}

Component 2: indices [1,2] → chars {c,a} → sorted {a,c}
→ Result = "bacd"

**Match**

This problem maps directly to graph connectivity:

Each index = node

Each pair = undirected edge

Swaps can occur among all nodes within the same connected component.

Efficient strategies:

DSU (Disjoint Set Union / Union-Find) → Efficient merging and grouping

Alternatives: BFS or DFS (less efficient for repeated union operations)

**Plan**

Initialize a DSU structure for all indices.

Union each index pair [a, b].

Traverse all indices and group them by their root parent (i.e., same connected component).

For each group:

Collect all characters corresponding to those indices.

Sort the characters lexicographically.

Reassign them back to the sorted indices.

Return the joined string.

**Implement**

```py
from collections import defaultdict
from typing import List

class DSU:
    def __init__(self, n):
        self.par = [i for i in range(n)]
        self.rank = [1 for _ in range(n)]

    def find(self, node):
        while node != self.par[node]:
            self.par[node] = self.par[self.par[node]]  # Path compression
            node = self.par[node]
        return node

    def union(self, a, b):
        pa, pb = self.find(a), self.find(b)
        if pa == pb:
            return False
        if self.rank[pa] > self.rank[pb]:
            self.par[pb] = pa
            self.rank[pa] += self.rank[pb]
        else:
            self.par[pa] = pb
            self.rank[pb] += self.rank[pa]
        return True


class Solution:
    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:
        dsu = DSU(len(s))
        for a, b in pairs:
            dsu.union(a, b)

        groups = defaultdict(list)
        for i in range(len(s)):
            parent = dsu.find(i)
            groups[parent].append(i)

        res = [''] * len(s)
        for parent, indices in groups.items():
            chars = sorted(s[i] for i in indices)
            for idx, ch in zip(sorted(indices), chars):
                res[idx] = ch

        return ''.join(res)
```

**Review**

Correctness: Verified with multiple cases (no pairs, single component, multiple components).

Efficiency: Each find/union operation is nearly O(1); sorting dominates runtime.

Readability: Clear DSU structure and logical flow of reconstruction.

**Evaluate**
Metric Description
Time Complexity O(N log N) — due to sorting within each component
Space Complexity O(N) — DSU arrays + grouping map
