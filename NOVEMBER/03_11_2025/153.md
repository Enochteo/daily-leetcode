## Find Minimum in Rotated Sorted Array

**Understand**

You are given a rotated sorted array of unique elements.
Return the minimum element of the array.

The array was originally sorted in ascending order but then rotated at some pivot.
You must find the minimum in O(log n) time.

Example 1:

Input: nums = [3,4,5,1,2]
Output: 1
Explanation: Rotated at index 3 → [1,2,3,4,5]

**Match**

This is a binary search on a rotated sorted array.

Key Insight:
In a rotated array, the smallest element is the pivot point —
the only place where the array “drops” from a higher to a lower value.

We compare nums[mid] to nums[r] to determine which half contains the minimum:

If nums[mid] < nums[r] → the minimum is in the left half, including mid.

Else → the minimum is in the right half (so move l = mid + 1).

**Plan**

Initialize pointers: l = 0, r = len(nums) - 1.

While l < r:

Compute mid = (l + r) // 2.

If nums[mid] < nums[r], the minimum lies left → r = mid.

Else, move right → l = mid + 1.

When loop ends, l points to the minimum.

Return nums[l].
