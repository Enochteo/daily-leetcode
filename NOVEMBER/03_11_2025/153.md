## Find Minimum in Rotated Sorted Array

**Understand**

You are given a rotated sorted array of unique elements.
Return the minimum element of the array.

The array was originally sorted in ascending order but then rotated at some pivot.
You must find the minimum in O(log n) time.

Example 1:

Input: nums = [3,4,5,1,2]
Output: 1
Explanation: Rotated at index 3 → [1,2,3,4,5]

**Match**

This is a binary search on a rotated sorted array.

Key Insight:
In a rotated array, the smallest element is the pivot point —
the only place where the array “drops” from a higher to a lower value.

We compare nums[mid] to nums[r] to determine which half contains the minimum:

If nums[mid] < nums[r] → the minimum is in the left half, including mid.

Else → the minimum is in the right half (so move l = mid + 1).

**Plan**

Initialize pointers: l = 0, r = len(nums) - 1.

While l < r:

Compute mid = (l + r) // 2.

If nums[mid] < nums[r], the minimum lies left → r = mid.

Else, move right → l = mid + 1.

When loop ends, l points to the minimum.

Return nums[l].

**Implement**

```py
class Solution(object):
    def findMin(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        l, r = 0, len(nums) - 1
        while l < r:
            mid = (l + r) // 2
            if nums[mid] < nums[r]:
                r = mid
            else:
                l = mid + 1
        return nums[l]
```

**Review**

Pure O(log n) binary search — no need for linear traversal.
Handles both rotated and non-rotated arrays.
Works even when rotation count = 0.

**Evaluate**

Time Complexity: O(log n)

Space Complexity: O(1)

Edge Cases:

Already sorted → returns first element.

Rotation at the last element → still correct.
