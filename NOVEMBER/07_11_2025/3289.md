## Get Sneaky Numbers

**Understand**

We are asked to find numbers that appear exactly twice (called “sneaky numbers”) in a given list nums.
The input may include zeros, and the solution must run in O(n) time and O(1) extra space.

Example:

Input: nums = [0, 0, 3, 1, 2, 3]
Output: [0, 3]

Reasoning:

0 appears twice → sneaky

3 appears twice → sneaky

Others appear once → not sneaky

Goal:
Return all sneaky numbers using only the input array (constant space).

**Match**

This is a frequency detection problem similar to LeetCode 442 (Find All Duplicates in an Array).
We use the index marking trick:

Treat the array index as a hash key.

Negate the number at index abs(nums[i]) to mark it as seen.

If we find it already negative → it’s a duplicate (sneaky).

However, 0 cannot be used for marking (since -0 = 0), so it requires special handling.

**Plan**

Initialize:

res = [] (to store sneaky numbers)

zero = 0 (count how many zeros appear)

Two pointers l and r for removing zeros safely.

Handle zeros:

Iterate through the list.

If nums[l] == 0, increment zero, swap it to the end, and pop it from the array.

Keep track of how many zeros were found.

If zero == 2, append 0 to res (sneaky zero).

Mark nonzero duplicates in-place:

For each n in nums:

Compute x = abs(n).

If nums[x] < 0, it means x was seen before → append x to res.

Else, mark it as seen: nums[x] = -nums[x].

Return res.

**Implement**

```py
class Solution:
    def getSneakyNumbers(self, nums: List[int]) -> List[int]:
        res = []
        l, r = 0, len(nums) - 1
        zero = 0

        #  Remove zeros safely
        while l < len(nums):
            while l < len(nums) and nums[l] == 0:
                zero += 1
                nums[l], nums[r] = nums[r], nums[l]
                nums.pop()
                r -= 1
            l += 1

        # Check if zero was sneaky
        if zero == 2:
            res.append(0)

        #  Use in-place index marking to find duplicates
        for i, n in enumerate(nums):
            x = abs(n)
            if nums[x] < 0:
                res.append(x)
            else:
                nums[x] = -nums[x]

        return res
```

**Review**

Handles zero separately to avoid index issues.
Uses O(1) extra space by reusing the input array for marking.
Efficient — each element processed once.

Edge Cases:

[0, 0] → [0]

[1, 2, 3] → []

[2, 2, 0, 0] → [0, 2]

[1, 1, 2, 2, 3, 3] → [1, 2, 3]

**Evaluate**
Time Complexity O(N) — one pass for zero cleanup + one pass for marking
Space Complexity O(1) — in-place marking, no extra data structures
Approach Index marking + special zero handling
Edge Handling Correctly isolates and counts zeros before mutation

**Pattern to Remember**

This problem uses the In-Place Index Marking Pattern, which is ideal when:

You’re working with an array of nonnegative integers (≤ len(nums) - 1).

You need to detect duplicates without extra space.
Special cases like zero must be handled separately since they cannot be negated for marking.
