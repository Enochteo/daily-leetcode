## Perfect Number

**Understand**

A perfect number is a positive integer equal to the sum of all its positive divisors excluding itself.

Example:

6 → 1 + 2 + 3 = 6 → Perfect

28 → 1 + 2 + 4 + 7 + 14 = 28 → Perfect

12 → 1 + 2 + 3 + 4 + 6 = 16 → Not Perfect

Goal:
Return True if num is a perfect number, else False.

**Match**

This is a number theory problem involving divisor summation.
Instead of iterating from 1 to num-1, we can reduce the range using symmetry in divisor pairs:

For any divisor i, there exists a complement num / i.

Only need to check divisors up to √num.

We’ll sum both i and num // i when i divides num exactly.

**Plan**

Initialize divisors_sum = 1 since 1 is always a divisor (except for num = 1).

Iterate i from 2 to √num:

If num % i == 0:

If i \* i == num, add only i.

Else, add both i and num // i.

After the loop, compare:

Return True if divisors_sum == num and num != 1.

Otherwise, False.

**Implement**

```py
import math

class Solution:
    def checkPerfectNumber(self, num: int) -> bool:
        if num <= 1:
            return False

        divisors_sum = 1
        for i in range(2, int(math.sqrt(num)) + 1):
            if num % i == 0:
                if i * i == num:
                    divisors_sum += i
                else:
                    divisors_sum += (i + (num // i))
        return divisors_sum == num
```

**Review**

Avoids unnecessary looping to num-1
Uses square root optimization
Handles perfect squares properly to avoid double counting

**Evaluate**
Metric Analysis
Time Complexity O(√N) — iterates up to square root of num
Space Complexity O(1) — constant extra space
Approach Mathematical divisor summation

**Pattern to Remember**

This follows the Divisor Pair Summation Pattern, common in problems requiring factor analysis.
Instead of brute-forcing all divisors, iterate only up to √N and add both divisor pairs to optimize runtime.
