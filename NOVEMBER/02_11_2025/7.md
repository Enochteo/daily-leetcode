## Reverse Integer

**Understand**

Given a 32-bit signed integer x, return its digits reversed.
If reversing causes the value to go outside the signed 32-bit integer range [-2³¹, 2³¹ − 1], return 0.

**Match**

This problem tests integer manipulation and overflow detection.
The main challenge: reverse digits mathematically (without converting to string) and ensure the result fits in 32-bit range.

Pattern: Extract digits with modulus and rebuild in reverse order.

**Plan**

Record the sign of x.

Work with the absolute value for simplicity.

Initialize res = 0.

While x is not zero:

Extract the last digit using x % 10.

Add it to res after shifting current digits left (res = res \* 10 + digit).

Remove the last digit from x using integer division (x //= 10).

Check for overflow (res outside 32-bit signed range).

Restore the sign and return.

**Implement**

```py
class Solution:
    def reverse(self, x: int) -> int:
        sign = x < 0
        x = abs(x)
        res = 0
        while x:
            res = res * 10 + (x % 10)
            x //= 10
        if res > 2147483647 or res < -2147483647:
            return 0
        return res if not sign else -res
```

**Review**

Handles negative numbers via sign flag.
Reverses digits mathematically (no string conversion).
Correctly returns 0 for overflow conditions.
Clean and minimal logic.
