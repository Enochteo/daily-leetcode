## Min Stack

**Understand**

Design a stack that supports push, pop, top, and retrieving the minimum element — all in constant time.

Methods:

push(val) → insert an element onto the stack.

pop() → remove the top element.

top() → return the top element.

getMin() → return the smallest element in the stack.

[null,null,null,null,-3,null,0,-2]

**Match**
This is a stack design pattern problem with an auxiliary data structure to maintain the minimum efficiently.

Key idea:

Maintain two stacks:

stack: stores all values.

minStack: stores current minimums (only updated when a new min is pushed or popped).

Thus, the top of minStack always gives the minimum so far.

**Plan**

Initialize two empty lists:

stack for all values.

minStack for tracking minimums.

push(val):

Append to stack.

If minStack is empty or val ≤ minStack[-1], append val to minStack.

pop():

If top of both stacks are equal, pop from both.

Otherwise, pop only from stack.

top(): return stack[-1].

getMin(): return minStack[-1].

**Implement**

```py
class MinStack:

    def __init__(self):
        self.stack = []
        self.minStack = []

    def push(self, val: int) -> None:
        if not self.minStack or self.minStack[-1] >= val:
            self.minStack.append(val)
        self.stack.append(val)

    def pop(self) -> None:
        if self.minStack[-1] == self.stack[-1]:
            self.minStack.pop()
            self.stack.pop()
        else:
            self.stack.pop()

    def top(self) -> int:
        return self.stack[-1]

    def getMin(self) -> int:
        return self.minStack[-1]
```

**Review**

Each operation runs in O(1) time.
Maintains constant extra space per element (two parallel stacks).
Keeps minimums synchronized with main stack.
