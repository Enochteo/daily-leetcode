## Find Median from Data Stream

**Understand**

We need a data structure that supports:

addNum(num) → add a new number to the data stream

findMedian() → return the median of all elements so far

The median is:

Middle element if total count is odd.

Average of two middle elements if total count is even.

Example:

Input:
["MedianFinder", "addNum", "addNum", "findMedian", "addNum", "findMedian"]
[[], [1], [2], [], [3], []]

Output:
[null, null, null, 1.5, null, 2.0]

**Match**

This is a streaming median problem.
We need to efficiently insert numbers and maintain quick access to the middle element.

Key idea:
Use two heaps:

Max-heap (less) → stores the smaller half of numbers (invert sign to simulate max-heap in Python).

Min-heap (greater) → stores the larger half of numbers.

Balance them so that their sizes differ by at most 1.

**Plan**

Maintain two heaps:

less: max-heap (store negatives of smaller numbers).

greater: min-heap (store larger numbers).

On inserting a number:

If less is not empty and num > -less[0], it belongs to greater.

Else, push it into less.

Rebalance:

If greater has more than one extra element → move one to less.

If less has more than one extra element → move one to greater.

To find the median:

If both heaps have equal size → average of roots.

If one heap is larger → root of that heap.

**Implement**

```py
class MedianFinder:

    def __init__(self):
        self.less = []      # max-heap (invert values)
        self.greater = []   # min-heap

    def addNum(self, num: int) -> None:
        if self.less and num > -self.less[0]:
            heapq.heappush(self.greater, num)
        else:
            heapq.heappush(self.less, -num)

        # rebalance heaps if needed
        if len(self.greater) - len(self.less) > 1:
            heapq.heappush(self.less, -heapq.heappop(self.greater))
        if len(self.less) - len(self.greater) > 1:
            heapq.heappush(self.greater, -heapq.heappop(self.less))

    def findMedian(self) -> float:
        total = len(self.less) + len(self.greater)
        if total % 2 == 0:
            return (-self.less[0] + self.greater[0]) / 2
        elif len(self.less) > len(self.greater):
            return -self.less[0]
        else:
            return self.greater[0]
```
