## Decode Ways

**Understand**

A message containing digits can be decoded using the mapping 'A' -> 1, 'B' -> 2, … 'Z' -> 26.

Given a string s containing only digits, return the total number of ways to decode it.

Example:

Input: s = "226"
Output: 3
Explanation: "226" can be decoded as:
"A B F" (1 2 6)
"V F" (22 6)
"B Z" (2 26)

Edge case:

"0" → 0 ways (no valid encoding starts with 0)

"10" → 1 way ("J")

**Match**

This is a Dynamic Programming (DFS + Memoization) problem.
At each position in the string, you can:

Decode one digit (if it’s not '0').

Decode two digits (if the two-digit number ≤ 26).

We recursively explore both options and cache intermediate results for efficiency.

**Plan**

Use a recursive helper dfs(index) that returns the number of decoding ways starting at position index.

Base Cases:

If index == len(s): one valid decoding path → return 1.

If s[index] == '0': invalid start → return 0.

Recursive Steps:

Decode single digit: dfs(index + 1)

If next two digits form a number ≤ 26, also do dfs(index + 2).

Sum results and store in cache (lru_cache handles memoization).

Return dfs(0) as the total number of decoding ways.

**Implement**

```py
class Solution:
    def numDecodings(self, s: str) -> int:
        @lru_cache()
        def dfs(index):
            if index == len(s):
                return 1
            if s[index] == '0':
                return 0
            res = dfs(index + 1)
            if index + 1 < len(s) and int(s[index:index + 2]) <= 26:
                res += dfs(index + 2)
            return res
        return dfs(0)
```

**Review**

Uses recursion with caching to avoid re-evaluating overlapping subproblems.

Handles zeros and invalid combinations correctly.

Equivalent to bottom-up DP but easier to read recursively.

**Evaluate**

Time Complexity: O(n) — each index computed once.

Space Complexity: O(n) — recursion depth and memoization cache.

**Pattern to remember**

For string decoding or partitioning problems:

Use DFS + memoization (Top-Down DP).

Define a clear base case for valid/invalid substrings.

Combine smaller subproblems (1-digit and 2-digit decisions).

Always check for leading zeros to prune invalid branches.
