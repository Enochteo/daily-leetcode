## All Possible Full Binary Trees

**Understand**

You are given an integer n, representing the number of nodes.
Your task is to return all possible full binary trees (FBTs) with n nodes.

A full binary tree is a tree where every node has either 0 or 2 children.

Each nodeâ€™s value is 0.
Return the list of all possible FBT roots.

**Example**:

Input: n = 7
Output: [[0,0,0,null,null,0,0,null,null,0,0], [0,0,0,null,null,0,0,0,0]]
Explanation: There are two possible full binary trees with 7 nodes.

Constraints:

1 <= n <= 20

**Match**

This is a recursion + memoization problem (similar to generating all unique BSTs).

Full binary trees must have odd node counts (n must be odd).

We recursively partition nodes between left and right subtrees and combine all possibilities.

Use memoization to store computed results for each n to avoid recomputation.

**Plan**

Base Cases:

If n == 1, return a single node [TreeNode(0)].

If n is even, return an empty list [] (cannot form a full tree).

Recursive Step:

Iterate over odd splits of nodes: left subtree with i nodes and right with n - 1 - i.

Recursively generate all left and right subtree combinations.

For each combination, attach them to a new root node and add to results.

Memoize the computed results for each n in a cache to prevent reprocessing.

Return all possible tree roots.
