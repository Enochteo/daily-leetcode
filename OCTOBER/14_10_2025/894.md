## All Possible Full Binary Trees

**Understand**

You are given an integer n, representing the number of nodes.
Your task is to return all possible full binary trees (FBTs) with n nodes.

A full binary tree is a tree where every node has either 0 or 2 children.

Each nodeâ€™s value is 0.
Return the list of all possible FBT roots.

**Example**:

Input: n = 7
Output: [[0,0,0,null,null,0,0,null,null,0,0], [0,0,0,null,null,0,0,0,0]]
Explanation: There are two possible full binary trees with 7 nodes.

Constraints:

1 <= n <= 20

**Match**

This is a recursion + memoization problem (similar to generating all unique BSTs).

Full binary trees must have odd node counts (n must be odd).

We recursively partition nodes between left and right subtrees and combine all possibilities.

Use memoization to store computed results for each n to avoid recomputation.

**Plan**

Base Cases:

If n == 1, return a single node [TreeNode(0)].

If n is even, return an empty list [] (cannot form a full tree).

Recursive Step:

Iterate over odd splits of nodes: left subtree with i nodes and right with n - 1 - i.

Recursively generate all left and right subtree combinations.

For each combination, attach them to a new root node and add to results.

Memoize the computed results for each n in a cache to prevent reprocessing.

Return all possible tree roots.

**Implement**

```py
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

class Solution:
    def allPossibleFBT(self, n: int) -> List[Optional[TreeNode]]:
        cache = {}

        def recurse(n):
            if n in cache:
                return cache[n]
            if n == 1:
                return [TreeNode()]
            if n % 2 == 0:
                return []

            res = []
            for i in range(1, n):
                left_tree = recurse(i)
                right_tree = recurse(n - i - 1)
                for left in left_tree:
                    for right in right_tree:
                        res.append(TreeNode(0, left, right))
            cache[n] = res
            return res

        return recurse(n)
```

**Review**

Uses top-down recursion with caching to optimize overlapping subproblems.

Only builds trees for odd node counts.

Ensures all possible left-right structural combinations are captured.

**Evaluate**

Time Complexity: Exponential in n (roughly O(Catalan(n/2))) due to tree combinations.

Space Complexity: O(n) recursion depth + memoization storage.
