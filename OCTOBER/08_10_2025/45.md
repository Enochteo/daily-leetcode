## Jump Game II

**Understand**

You are given an integer array nums, where each element represents the maximum jump length at that position.

Your goal is to reach the last index in the minimum number of jumps.

Example:

```
Input: nums = [2,3,1,1,4]
Output: 2
Explanation: Jump 1 → index 1, then jump 3 → index 4.

Input: nums = [2,3,0,1,4]
Output: 2
```

**Match**

This is a greedy range expansion problem.
We track:

cur_reach: the farthest index reachable with the current number of jumps.

max_reach: the farthest index reachable with one more jump.

When we move past the current range (i >= cur_reach),
we increment the jump counter and extend the range to max_reach.

This greedy approach ensures minimal jumps without backtracking.

**Plan**

Initialize:

cur_reach = nums[0] → current jump limit.

max_reach = 0 → next jump's potential reach.

jumps = 0.

Iterate through nums:

Update max_reach = max(max_reach, i + nums[i]).

If i reaches the current boundary (i >= cur_reach):

Increment jumps.

Update cur_reach = max_reach.

Return total jumps.

**Implement**

```py
class Solution():
    def jump(self, nums: List[int]) -> int:
        cur_reach = nums[0]
        max_reach = 0
        jumps = 0
        for i in range(1, len(nums)):
            if i >= cur_reach:
                jumps += 1
                cur_reach = max_reach
            max_reach = max(max_reach, i + nums[i])
        return jumps
```

**Review**

Efficiently tracks current and future jump ranges.

Avoids redundant exploration seen in BFS or DP.

Works in one forward pass.

**Evaluate**

Time Complexity: O(n) — single traversal through array.

Space Complexity: O(1) — constant extra space.

**Pattern to remember**

For minimum jump problems (like Jump Game II):

Use greedy range expansion.

Track current range end (cur_reach) and next max reach (max_reach).

Increment jumps only when crossing the current range.
