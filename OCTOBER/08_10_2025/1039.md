## Minimum Score Triangulation of Polygon

**Understand**

You are given an array values of length n, where values[i] represents the vertex value of a convex polygon.

You must triangulate the polygon into n - 2 triangles such that the sum of the triangle scores is minimized.

The score of each triangle is the product of its vertices' values.

Triangles can share edges and vertices.

**Match**

This is an Interval Dynamic Programming problem (similar to Matrix Chain Multiplication).

We’re finding the optimal way to split the polygon into triangles.

Each triangle forms between two fixed vertices (i, j) and a middle vertex k.

Recursive substructure:

```
dp[i][j] = min(dp[i][k] + dp[k][j] + values[i]*values[j]*values[k])
```

Memoization ensures we don’t recompute overlapping subproblems.

**Plan**

Define recursive function dfs(i, j) → minimum triangulation score for subpolygon from vertex i to j.

Base case:

If fewer than 3 vertices → no triangle possible → return 0.

For each possible k between i+1 and j-1:

Compute triangle cost values[i] _ values[j] _ values[k].

Add costs of subproblems dfs(i, k) and dfs(k, j).

Track the minimum total.

Memoize results with @lru_cache.

Return dfs(0, n-1) for full polygon.

**Implement**

```py
from functools import lru_cache

class Solution:
    def minScoreTriangulation(self, values: List[int]) -> int:
        @lru_cache(None)
        def dfs(i, j):
            if j - i < 2:
                return 0
            res = float('inf')
            for k in range(i + 1, j):
                res = min(res, values[i] * values[j] * values[k] + dfs(i, k) + dfs(k, j))
            return res
        return dfs(0, len(values) - 1)
```

**Review**

Uses memoized recursion (top-down DP) for efficiency.

Each subproblem (i, j) is solved once.

Combines all possible splits k to ensure minimum score.

**Evaluate**

Time Complexity: O(n³) — for each (i, j) pair, loop over all k in range.

Space Complexity: O(n²) — memoization table for all (i, j) pairs.
