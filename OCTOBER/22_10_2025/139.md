## Word Break

**Understand**

You are given a string s and a list of words wordDict.
Determine if s can be segmented into one or more dictionary words.

Each word in the dictionary can be used multiple times.

Example:

Input: s = "leetcode", wordDict = ["leet","code"]
Output: True
Explanation: "leetcode" = "leet" + "code"

Input: s = "applepenapple", wordDict = ["apple","pen"]
Output: True
Explanation: "applepenapple" = "apple" + "pen" + "apple"

Input: s = "catsandog", wordDict = ["cats","dog","sand","and","cat"]
Output: False

**Match**

This is a string segmentation problem that can be solved using DFS with memoization.
However, instead of repeatedly checking substrings in a dictionary (O(n²) overhead), we use a Trie for efficient prefix checking.

Each Trie path represents a possible prefix in wordDict.
We recursively explore s, moving down the Trie as long as characters match, restarting from the root when a word boundary (EoW) is reached.

**Plan**

Build a Trie of all words in wordDict.

Use a recursive function dfs(index, node) that checks if substring s[index:] can form valid words:

Base case: If index == len(s), return whether the current Trie node marks an end of a valid word (EoW).

If at end of word (EoW=True):

Try restarting from the Trie root to start a new word from the same index.

If possible, branch into continuing from the current node as well (for overlapping prefixes).

If current character exists in children: move deeper in Trie and continue recursion.

Otherwise, return False.

Use lru_cache() to memoize (index, node) results to avoid recomputation.

Return dfs(0, trie.root).

**Implement**

```py
class TrieNode:
    def __init__(self):
        self.children = {}
        self.EoW = False

class Trie:
    def __init__(self):
        self.root = TrieNode()

    def addword(self, word: str):
        node = self.root
        for c in word:
            if c not in node.children:
                node.children[c] = TrieNode()
            node = node.children[c]
        node.EoW = True

class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        trie = Trie()
        for word in wordDict:
            trie.addword(word)

        @lru_cache()
        def dfs(index, node):
            if index == len(s):
                return node.EoW
            if node.EoW:
                if s[index] in node.children:
                    return dfs(index + 1, node.children[s[index]]) or dfs(index, trie.root)
                return dfs(index, trie.root)
            if s[index] in node.children:
                if dfs(index + 1, node.children[s[index]]):
                    return True
            return False

        return dfs(0, trie.root)
```

**Review**

Builds a Trie for efficient prefix matching of words.

Uses DFS + memoization to avoid redundant recomputation of overlapping subproblems.

Supports dynamic branching when multiple valid segmentations exist.

Optimized for large dictionaries and deep recursion paths.

**Evaluate**

Time Complexity: O(n × m), where n = len(s) and m = max word length (bounded by Trie traversal).

Space Complexity: O(n × m) for recursion stack, Trie, and memoization cache.

**Pattern to remember**

For string segmentation and prefix-based search problems:

Use a Trie to store valid dictionary prefixes.

Combine DFS + memoization for efficient backtracking.

Restart from Trie root upon reaching an end-of-word marker (EoW).

Same pattern generalizes to problems like Word Search II and Concatenated.
