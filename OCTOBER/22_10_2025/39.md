## Combination Sum

**Understand**

You are given an array of distinct positive integers candidates and an integer target.
Return a list of all unique combinations where the chosen numbers sum to target.
You may use the same number multiple times.
Combinations can be returned in any order.

Example:

Input: candidates = [2,3,6,7], target = 7
Output: [[2,2,3],[7]]
Explanation:

- 2 + 2 + 3 = 7
- 7 = 7

Input: candidates = [2,3,5], target = 8
Output: [[2,2,2,2],[2,3,3],[3,5]]

Constraints:

1 <= candidates.length <= 30

2 <= candidates[i] <= 40

1 <= target <= 40

All numbers are distinct.

**Match**

This is a backtracking problem — exploring all combinations of numbers that sum to a target.
At each step, you either:

Include the current number and stay at the same index (allow reuse), or

Move to the next index to try a new number.

The structure follows a classic DFS with pruning pattern.

**Plan**

Initialize an empty result list res.

Define a recursive function dfs(i, path) where:

i is the current index in candidates.

path stores the current combination being built.

Base cases:

If sum(path) == target: add a copy of path to res.

If i >= len(candidates) or sum(path) > target: stop recursion.

Recursive exploration:

Choose current candidate: call dfs(i, path + [candidates[i]]).

Skip current candidate: call dfs(i + 1, path).

Start with dfs(0, []) and return res after completion.

**Implement**

```py
class Solution:
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        res = []
        def dfs(i, path):
            if sum(path) == target:
                res.append(path[:])
                return
            if i >= len(candidates) or sum(path) > target:
                return
            dfs(i, path + [candidates[i]])
            dfs(i + 1, path)
        dfs(0, [])
        return res
```

**Review**

Explores all valid combinations recursively.

Allows reuse of elements by staying at index i when including the same candidate.

Stops early when current path sum exceeds target.

**Evaluate**

Time Complexity: O(2ⁿ) worst-case — exploring all inclusion/exclusion combinations.

Space Complexity: O(n) recursion depth plus storage for valid paths.
