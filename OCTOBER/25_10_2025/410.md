## Split Array Largest Sum

**Understand**

You are given an integer array nums and an integer k.
Split the array into k non-empty continuous subarrays, and return the minimum possible value of the largest subarray sum among all possible splits.

Example:

Input: nums = [7,2,5,10,8], k = 2
Output: 18
Explanation:

- Split into [7,2,5] and [10,8]
- Largest subarray sum = max(14,18) = 18 (minimum possible)

Input: nums = [1,2,3,4,5], k = 2
Output: 9
Explanation:

- Split into [1,2,3,4] and [5] → max = 10
- Split into [1,2,3] and [4,5] → max = 9

Constraints:

1 ≤ nums.length ≤ 1000

0 ≤ nums[i] ≤ 10⁶

1 ≤ k ≤ nums.length

**Match**

This problem fits dynamic programming with recursion + memoization.
You are asked to partition an array into k contiguous groups minimizing the maximum subarray sum, a classic partition DP pattern.

Each recursive state defines:

Current starting index (index)

Remaining splits (k)

and tries all valid partitions to find the optimal one.

**Plan**

Use DFS with memoization (cache) to avoid recomputation of overlapping subproblems.

Define recursive function dfs(index, k) that returns the minimum largest subarray sum from index → end when splitting into k parts.

Base cases:

If k == 1, only one partition left — take the sum of the remaining elements.

If remaining elements are fewer than k, impossible → return infinity.

For each possible split position i:

Accumulate running sum cur_sum from index to i.

Recurse into dfs(i + 1, k - 1) for the remaining parts.

Track the minimal possible value of max(cur_sum, next_split_sum).

Prune when cur_sum > best (since sums only increase).

Return the result of dfs(0, k).

**Implement**

```py
class Solution(object):
    def splitArray(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: int
        """
        cache = {}

        def dfs(index, k):
            if (index, k) in cache:
                return cache[(index, k)]
            if k == 1:
                return sum(nums[index:])
            if len(nums) - index < k:
                return float('inf')

            best = float('inf')
            cur_sum = 0

            for i in range(index, len(nums) - (k - 1)):
                cur_sum += nums[i]
                split_sums = dfs(i + 1, k - 1)
                best = min(best, max(cur_sum, split_sums))
                if cur_sum > best:  # pruning for efficiency
                    break

            cache[(index, k)] = best
            return best

        return dfs(0, k)
```

**Review**

Uses recursion with memoization to avoid redundant computations.
Includes pruning condition if cur_sum > best to skip unnecessary iterations.
Handles edge cases where elements left are fewer than partitions.
Top-down approach improves readability and modular reasoning.
