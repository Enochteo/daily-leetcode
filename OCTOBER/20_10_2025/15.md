## 3Sum

**Understand**

You are given an integer array nums.
Return all unique triplets [a, b, c] in the array such that:

a + b + c == 0

Triplets should not contain duplicates and can appear in any order.

Example:

Input: nums = [-1, 0, 1, 2, -1, -4]
Output: [[-1, -1, 2], [-1, 0, 1]]
Explanation:

- (-1, -1, 2) → sum = 0
- (-1, 0, 1) → sum = 0

**Match**

This is a two-pointer search problem on a sorted array — a classic variant of 3Sum.
By sorting and fixing one number at a time, we can reduce the problem to a 2Sum search on the remainder of the array using two pointers (l and r).

**Plan**

Sort the array to simplify duplicate handling and enable two-pointer scanning.

Initialize an empty list res to store unique triplets.

For each index start in the array:

Skip duplicate values (nums[start] == nums[start - 1]).

Set target = -nums[start].

Use two pointers:

l = start + 1

r = len(nums) - 1

While l < r:

Compute two_sum = nums[l] + nums[r].

If two_sum > target: move right pointer leftward (r -= 1).

If two_sum < target: move left pointer rightward (l += 1).

If equal, append [nums[start], nums[l], nums[r]] to result and skip duplicate values at l.

Continue until all unique triplets are processed.

**Implement**

```py
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        res = []
        nums.sort()
        for start in range(len(nums)):
            if start > 0 and nums[start] == nums[start - 1]:
                continue
            target = -nums[start]
            l = start + 1
            r = len(nums) - 1
            while l < r:
                two_sum = nums[l] + nums[r]
                if two_sum > target:
                    r -= 1
                elif two_sum < target:
                    l += 1
                else:
                    res.append([nums[start], nums[l], nums[r]])
                    l += 1
                    while l < r and nums[l] == nums[l - 1]:
                        l += 1
        return res
```

**Review**

Sorting ensures duplicates are easily avoided.

Two-pointer scanning provides O(n²) performance instead of O(n³).

Duplicate checks at both outer (start) and inner (l) levels ensure unique triplets.

**Evaluate**

Time Complexity: O(n²) — each outer loop iteration runs a two-pointer scan.

Space Complexity: O(1) — aside from the output list.

**Pattern to remember**

For 3Sum / kSum problems:

Sort the array first.

Fix one number and reduce the rest to a two-pointer 2Sum.

Always skip duplicates both in the outer loop and inside the two-pointer loop.

Works as a template for extensions like 4Sum, 3Sum Closest, and kSum.
