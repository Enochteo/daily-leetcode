## 3Sum

**Understand**

You are given an integer array nums.
Return all unique triplets [a, b, c] in the array such that:

a + b + c == 0

Triplets should not contain duplicates and can appear in any order.

Example:

Input: nums = [-1, 0, 1, 2, -1, -4]
Output: [[-1, -1, 2], [-1, 0, 1]]
Explanation:

- (-1, -1, 2) → sum = 0
- (-1, 0, 1) → sum = 0

**Match**

This is a two-pointer search problem on a sorted array — a classic variant of 3Sum.
By sorting and fixing one number at a time, we can reduce the problem to a 2Sum search on the remainder of the array using two pointers (l and r).

**Plan**

Sort the array to simplify duplicate handling and enable two-pointer scanning.

Initialize an empty list res to store unique triplets.

For each index start in the array:

Skip duplicate values (nums[start] == nums[start - 1]).

Set target = -nums[start].

Use two pointers:

l = start + 1

r = len(nums) - 1

While l < r:

Compute two_sum = nums[l] + nums[r].

If two_sum > target: move right pointer leftward (r -= 1).

If two_sum < target: move left pointer rightward (l += 1).

If equal, append [nums[start], nums[l], nums[r]] to result and skip duplicate values at l.

Continue until all unique triplets are processed.
