## House Robber

**Understand**

You are a professional thief planning to rob houses along a street.
Each house has a certain amount of money, represented by nums[i].
You cannot rob two adjacent houses because of security alarms.

Return the maximum amount of money you can rob without alerting the police.

Example:

```
Input: nums = [1,2,3,1]
Output: 4
Explanation:
Rob house 1 (money = 1) and house 3 (money = 3) → total = 4
```

**Match**

This is a Dynamic Programming (DP) problem.
It can be solved both iteratively (bottom-up DP) and recursively with memoization (top-down DFS).
At each house, you have two choices:

Rob the current house and skip the next (+2).

Skip the current house and consider the next (+1).

**Plan**
Approach 1 – Bottom-Up DP (Iterative)

Initialize a DP array of size len(nums) + 2 to handle edge cases easily.

Traverse nums in reverse:

For each index i, compute:

dp[i] = max(nums[i] + dp[i+2], dp[i+1])

Meaning: rob this house and add future non-adjacent profit, or skip it.

Return dp[0] as the maximum amount that can be robbed.

Approach 2 – Top-Down DFS + Memoization

Define a recursive helper dfs(index) returning the max money starting from house index.

Use memoization (cache) to store results and avoid recomputation.

At each step:

cache[index] = max(nums[index] + dfs(index + 2), dfs(index + 1))

Return dfs(0) for the optimal result.
