## House Robber

**Understand**

You are a professional thief planning to rob houses along a street.
Each house has a certain amount of money, represented by nums[i].
You cannot rob two adjacent houses because of security alarms.

Return the maximum amount of money you can rob without alerting the police.

Example:

```
Input: nums = [1,2,3,1]
Output: 4
Explanation:
Rob house 1 (money = 1) and house 3 (money = 3) → total = 4
```

**Match**

This is a Dynamic Programming (DP) problem.
It can be solved both iteratively (bottom-up DP) and recursively with memoization (top-down DFS).
At each house, you have two choices:

Rob the current house and skip the next (+2).

Skip the current house and consider the next (+1).

**Plan**
Approach 1 – Bottom-Up DP (Iterative)

Initialize a DP array of size len(nums) + 2 to handle edge cases easily.

Traverse nums in reverse:

For each index i, compute:

dp[i] = max(nums[i] + dp[i+2], dp[i+1])

Meaning: rob this house and add future non-adjacent profit, or skip it.

Return dp[0] as the maximum amount that can be robbed.

Approach 2 – Top-Down DFS + Memoization

Define a recursive helper dfs(index) returning the max money starting from house index.

Use memoization (cache) to store results and avoid recomputation.

At each step:

cache[index] = max(nums[index] + dfs(index + 2), dfs(index + 1))

Return dfs(0) for the optimal result.

**Implement**

```py
class Solution:
    def rob(self, nums: List[int]) -> int:
        # Bottom-up DP
        dp = [0] * (len(nums) + 2)
        for i in range(len(nums) - 1, -1, -1):
            dp[i] = max(dp[i + 2] + nums[i], dp[i + 1])
        return dp[0]

        # Top-down DFS with memoization
        cache = {}
        def dfs(index):
            if index in cache:
                return cache[index]
            if index >= len(nums):
                return 0
            cache[index] = max(nums[index] + dfs(index + 2), dfs(index + 1))
            return cache[index]
        return dfs(0)
```

**Review**

Both solutions yield the same result.

Bottom-up avoids recursion and uses O(n) time, O(n) space.

Top-down with memoization is easier to reason about recursively.

**Evaluate**

Time Complexity: O(n) — each house is processed once.

Space Complexity: O(n) — for DP array or memoization dictionary.

**Pattern to remember**

For “non-adjacent selection” or “maximum subset sum without consecutive elements” problems:

Use the relation dp[i] = max(nums[i] + dp[i+2], dp[i+1]).

Recursion and iteration are interchangeable depending on style or constraints.

This same pattern applies to related problems like House Robber II, Delete and Earn, and Paint House.
