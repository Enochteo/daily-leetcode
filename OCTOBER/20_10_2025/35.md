## Search Insert Position

**Understand**

Given a sorted array nums and an integer target, return the index where the target is found,
or the index where it would be inserted in order if not present.

Example:

Input: nums = [1,3,5,6], target = 5
Output: 2

Input: nums = [1,3,5,6], target = 2
Output: 1

Input: nums = [1,3,5,6], target = 7
Output: 4

Constraints:

1 <= len(nums) <= 10⁴

-10⁴ <= nums[i], target <= 10⁴

nums is sorted in ascending order.

**Match**

This is a binary search problem — you need to either find the target or locate its correct insertion position in a sorted list.
Binary search efficiently narrows down the possible index range in O(log n) time.

**Plan**

Initialize two pointers:

l = 0 (start of array)

r = len(nums) - 1 (end of array)

While l <= r:

Compute midpoint mid = (l + r) // 2.

If nums[mid] == target, return mid.

If nums[mid] < target, move l to mid + 1 (target is in right half).

Else move r to mid - 1 (target is in left half).

If the loop ends without finding the target, l will be the insertion index.

Return l.

**Implement**

```py
class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:
        l, r = 0, len(nums) - 1
        while l <= r:
            mid = (l + r) // 2
            if nums[mid] == target:
                return mid
            elif nums[mid] < target:
                l = mid + 1
            else:
                r = mid - 1
        return l
```
