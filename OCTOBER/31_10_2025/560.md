## Subarray Sum Equals K

**Understand**

You are given an integer array nums and an integer k.
Return the total number of continuous subarrays whose sum equals k.

Example 1:

Input: nums = [1,1,1], k = 2  
Output: 2
Explanation: Subarrays [1,1] (index 0–1 and 1–2) both sum to 2.

Example 2:

Input: nums = [1,2,3], k = 3  
Output: 2 (subarrays [1,2], [3])

**Match**

This is a prefix sum + hashmap problem — a classic pattern for counting subarrays with specific sums in O(n).

Intuition:

If prefix[j] - prefix[i] = k, then the subarray nums[i:j] sums to k.

Rearranging → we need to know how many times a prefix sum equal to (current_sum - k) has appeared before.

Use a hashmap (prefix_map) to store the frequency of prefix sums encountered so far.

**Plan**

Initialize:

prefix_map = {0: 1} (for subarrays starting at index 0).

cur_sum = 0

res = 0 (count of valid subarrays).

Iterate through nums:

Update cur_sum += num.

If (cur_sum - k) is in prefix_map, increment result by its frequency (those subarrays end here).

Record cur_sum in prefix_map.

Return res.

**Implement**

```py
class Solution(object):
    def subarraySum(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: int
        """
        res = 0
        prefix_map = defaultdict(int)
        prefix_map[0] = 1
        cur_sum = 0

        for num in nums:
            cur_sum += num
            if cur_sum - k in prefix_map:
                res += prefix_map[cur_sum - k]
            prefix_map[cur_sum] += 1

        return res
```

**Review**

Uses prefix-sum differences to detect valid subarrays in O(n).
Handles negative numbers and zero correctly.
Prefix map initialized with {0: 1} to count subarrays starting from index 0.

Evaluate

Time Complexity: O(n)

Space Complexity: O(n) — for prefix sum hashmap.
