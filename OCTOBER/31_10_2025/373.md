## Find K Pairs with Smallest Sums

**Understand**

Given two sorted arrays nums1 and nums2, find the k pairs (u, v) with the smallest sums, where u comes from nums1 and v from nums2.

Example:

Input: nums1 = [1,7,11], nums2 = [2,4,6], k = 3  
Output: [[1,2],[1,4],[1,6]]

Explanation:
All pairs sorted by sum are:
[1,2], [1,4], [1,6], [7,2], [7,4], [11,2], …
The first 3 pairs have the smallest sums.

**Match**

This is a heap / k-way merge pattern — similar to merging sorted lists.
Because both arrays are sorted ascending, the smallest pairs start from (nums1[0], nums2[0]) and can be expanded systematically.

We can use a min-heap storing (sum, i, j) indices representing the pair (nums1[i], nums2[j]).

**Plan**

Initialize a heap with (nums1[0] + nums2[0], 0, 0).

Maintain a visited set to prevent duplicate index combinations.

Pop the smallest-sum pair (i, j) from the heap and add (nums1[i], nums2[j]) to the result.

Push the next two possible expansions if not visited:

(i + 1, j) — move down in nums1.

(i, j + 1) — move right in nums2.

Continue until you collect k pairs or the heap is empty.

**Implement**

```py
class Solution:
    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:
        heap = []
        visited = set()
        res = []

        # start from the smallest pair
        heapq.heappush(heap, (nums1[0] + nums2[0], 0, 0))
        visited.add((0, 0))

        while heap and len(res) < k:
            s, i, j = heapq.heappop(heap)
            res.append((nums1[i], nums2[j]))

            if i + 1 < len(nums1) and (i + 1, j) not in visited:
                heapq.heappush(heap, (nums1[i + 1] + nums2[j], i + 1, j))
                visited.add((i + 1, j))

            if j + 1 < len(nums2) and (i, j + 1) not in visited:
                heapq.heappush(heap, (nums1[i] + nums2[j + 1], i, j + 1))
                visited.add((i, j + 1))
        return res
```

**Review**

Efficiently avoids generating all m × n pairs.
Only explores the next valid neighbors in sorted order.
Uses a heap for O(log k) retrieval and expansion.
Visited set prevents duplicates from overlapping paths.
