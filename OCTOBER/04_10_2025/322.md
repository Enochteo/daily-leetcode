## Coin Change

**Understand**

We are given an array coins representing coin denominations and an integer amount.

We must return the fewest number of coins needed to make up that amount.
If it’s not possible, return -1.

```
Example:

Input: coins = [1,2,5], amount = 11
Output: 3
Explanation: 11 = 5 + 5 + 1

Input: coins = [2], amount = 3
Output: -1
```

**Constraints**:

````
1 <= coins.length <= 12

1 <= coins[i] <= 2^31 - 1

0 <= amount <= 10^4```
````

**Match**

This is a Dynamic Programming / DFS with memoization problem (unbounded knapsack type).

We can take any coin multiple times.

Subproblem: minCoins(target) = minimum coins needed to form target.

Recurrence:

minCoins(target) = min(1 + minCoins(target - coin)) for coin in coins

Use memoization to avoid recomputation.

**Plan**

Use DFS to explore all combinations recursively.

Base cases:

If target == 0: 0 coins needed.

If target < 0: invalid path → ∞.

For each coin c, compute 1 + dfs(target - c) and track the minimum.

Memoize each computed target.

Return memoized result for amount or -1 if impossible.
