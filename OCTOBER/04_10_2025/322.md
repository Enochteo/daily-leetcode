## Coin Change

**Understand**

We are given an array coins representing coin denominations and an integer amount.

We must return the fewest number of coins needed to make up that amount.
If it’s not possible, return -1.

```
Example:

Input: coins = [1,2,5], amount = 11
Output: 3
Explanation: 11 = 5 + 5 + 1

Input: coins = [2], amount = 3
Output: -1
```

**Constraints**:

````
1 <= coins.length <= 12

1 <= coins[i] <= 2^31 - 1

0 <= amount <= 10^4```
````

**Match**

This is a Dynamic Programming / DFS with memoization problem (unbounded knapsack type).

We can take any coin multiple times.

Subproblem: minCoins(target) = minimum coins needed to form target.

Recurrence:

minCoins(target) = min(1 + minCoins(target - coin)) for coin in coins

Use memoization to avoid recomputation.

**Plan**

Use DFS to explore all combinations recursively.

Base cases:

If target == 0: 0 coins needed.

If target < 0: invalid path → ∞.

For each coin c, compute 1 + dfs(target - c) and track the minimum.

Memoize each computed target.

Return memoized result for amount or -1 if impossible.

**Implement**

```py
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        memo = {}

        def dfs(target):
            if target < 0:
                return float('inf')
            if target == 0:
                return 0
            if target in memo:
                return memo[target]

            min_ways = float('inf')
            for c in coins:
                min_ways = min(min_ways, 1 + dfs(target - c))

            memo[target] = min_ways
            return min_ways

        optimal = dfs(amount)
        return optimal if optimal != float('inf') else -1
```

**Review**

Uses top-down recursion with memoization (avoids redundant computation).

Prunes invalid paths (target < 0).

Returns -1 when no valid combination exists.

**Evaluate**

Time Complexity: O(amount × n), where n = number of coins (each state computed once).

Space Complexity: O(amount) for recursion + memo storage.

**Pattern to remember**

For minimum coin / sum combination problems:

Use top-down DFS or bottom-up DP.

Base cases: 0 → 0, negative → ∞.

Recurrence: dp[i] = min(1 + dp[i - c]) for c in coins.
