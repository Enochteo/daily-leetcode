## Coin Change II

**Understand**

We are given an integer amount and a list of coin denominations coins.
We must return the number of combinations that make up the amount.

Each coin can be used unlimited times.

Order of coins does not matter (combinations, not permutations).

**Example**:

```
Input: amount = 5, coins = [1,2,5]
Output: 4
Explanation: 5 = 5, 2+2+1, 2+1+1+1, 1+1+1+1+1

Input: amount = 3, coins = [2]
Output: 0
```

**Constraints**:

1 <= coins.length <= 300

1 <= coins[i] <= 5000

0 <= amount <= 5000

**Match**

This is a Dynamic Programming problem with combinatorial recursion.
We explore all ways to form target using coins starting from a given index:

Two choices at each step:

Include the current coin → dfs(index, target - coins[index])

Exclude it → move to next coin → dfs(index + 1, target)

Memoization ensures each (index, target) is computed once.

**Plan**

Define dfs(index, target) → number of ways to make target using coins from index onward.

Base cases:

If target == 0 → 1 valid combination found.

If target < 0 or index == len(coins) → 0 ways.

Use memoization to store results for (index, target).

Recurrence:

dfs(index, target) = dfs(index, target - coins[index]) + dfs(index + 1, target)

Return dfs(0, amount).

**Implement**

```py
class Solution(object):
    def change(self, amount, coins):
        """
        :type amount: int
        :type coins: List[int]
        :rtype: int
        """
        memo = {}
        def dfs(index, target):
            if target == 0:
                return 1
            if target < 0 or index >= len(coins):
                return 0
            if (index, target) in memo:
                return memo[(index, target)]
            memo[(index, target)] = dfs(index, target - coins[index]) + dfs(index + 1, target)
            return memo[(index, target)]
        return dfs(0, amount)
```

**Review**

Avoids overcounting by always moving forward in the coin list.

Uses recursion with memoization for efficiency.

Correctly handles base and boundary cases.

**Evaluate**

Time Complexity: O(n × amount), each (index, target) computed once.

Space Complexity: O(n × amount) for memoization + recursion stack.
