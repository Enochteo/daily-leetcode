## Coin Change II

**Understand**

We are given an integer amount and a list of coin denominations coins.
We must return the number of combinations that make up the amount.

Each coin can be used unlimited times.

Order of coins does not matter (combinations, not permutations).

**Example**:

```
Input: amount = 5, coins = [1,2,5]
Output: 4
Explanation: 5 = 5, 2+2+1, 2+1+1+1, 1+1+1+1+1

Input: amount = 3, coins = [2]
Output: 0
```

**Constraints**:

1 <= coins.length <= 300

1 <= coins[i] <= 5000

0 <= amount <= 5000

**Match**

This is a Dynamic Programming problem with combinatorial recursion.
We explore all ways to form target using coins starting from a given index:

Two choices at each step:

Include the current coin → dfs(index, target - coins[index])

Exclude it → move to next coin → dfs(index + 1, target)

Memoization ensures each (index, target) is computed once.
