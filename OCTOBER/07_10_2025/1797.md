## Design Authentication Manager

**Understand**

You must design an authentication manager that manages session tokens with a fixed Time-To-Live (TTL) value.

Each token expires timeToLive seconds after it’s generated or renewed.
The system supports three operations:

generate(tokenId, currentTime) → creates a new token valid until currentTime + TTL.

renew(tokenId, currentTime) → refreshes the token’s expiry if it’s still valid.

countUnexpiredTokens(currentTime) → returns how many tokens are still valid at currentTime.

**Match**

This is a design + hash map problem:

We need O(1) lookup and update of expiry times → dictionary is ideal.

Each token maps to its expiry timestamp.

Renewal only occurs if the token hasn’t expired.

**Plan**

Initialize:

Store TTL in seconds.

Use a dictionary expiry mapping tokenId → expiry_time.

generate(tokenId, currentTime):

Insert or overwrite expiry[tokenId] = currentTime + TTL.

renew(tokenId, currentTime):

If tokenId exists and hasn’t expired (expiry[tokenId] > currentTime):

Update its expiry to currentTime + TTL.

countUnexpiredTokens(currentTime):

Iterate through expiry and count tokens whose expiry > currentTime.

**Implement**

```py
class AuthenticationManager:

    def __init__(self, timeToLive: int):
        self.TTL = timeToLive
        self.expiry = {}

    def generate(self, tokenId: str, currentTime: int) -> None:
        self.expiry[tokenId] = currentTime + self.TTL

    def renew(self, tokenId: str, currentTime: int) -> None:
        if tokenId in self.expiry:
            if self.expiry[tokenId] > currentTime:
                self.expiry[tokenId] = currentTime + self.TTL

    def countUnexpiredTokens(self, currentTime: int) -> int:
        count = 0
        for tid in self.expiry:
            if self.expiry[tid] > currentTime:
                count += 1
        return count
```

**Review**

Dictionary provides constant-time lookup and updates.

Renewal logic prevents expired tokens from being renewed.

Counting valid tokens checks expiry directly.

**Evaluate**

Time Complexity:

generate → O(1)

renew → O(1)

countUnexpiredTokens → O(n), where n = number of stored tokens.

Space Complexity: O(n), storing expiry times for all tokens.
