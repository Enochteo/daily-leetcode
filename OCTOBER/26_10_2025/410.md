## Split Array Largest Sum

**Understand**

You have an array nums and an integer k.
You must split nums into k non-empty continuous subarrays so that the largest subarray sum is as small as possible.
Return that minimum possible largest sum.

Example 1

Input: nums = [7,2,5,10,8], k = 2
Output: 18
Explanation:
Split [7,2,5] and [10,8]
max(14,18) = 18 → smallest achievable

**Match**

This is a binary-search on answer problem.
We are searching for the smallest possible upper bound X such that we can partition the array into at most k parts, each with sum ≤ X.

The helper canSplit(limit, k) uses a greedy check:
simulate forming groups whose partial sum never exceeds limit;
each time it would, start a new group.
If more than k groups are needed → limit too small.

**Plan**

Search range = [max(nums), sum(nums)]

smallest limit must at least cover the largest element;

largest limit is the sum of all numbers (one group).

Binary search mid = (l + r)//2.

Greedily test if array can be split into ≤ k groups with each group sum ≤ mid.

Maintain a running sum.

When adding next number exceeds mid, start new subarray and decrement group count.

If feasible → shrink right bound r = mid − 1 (try smaller max sum).
Else → grow left l = mid + 1.

Return l = minimal largest sum.

**Implement**

```py
class Solution:
    def splitArray(self, nums: List[int], k: int) -> int:
        l, r = max(nums), sum(nums)

        def canSplit(limit, groups):
            track_sum = 0
            for num in nums:
                track_sum += num
                if track_sum > limit:
                    track_sum = num
                    groups -= 1
                if groups <= 0:
                    return False
            return True

        while l <= r:
            mid = (l + r) // 2
            if canSplit(mid, k):
                r = mid - 1      # feasible, try smaller
            else:
                l = mid + 1      # not feasible, need larger
        return l
```
