## Integer Break

**Understand**

You are given an integer n.
You must break it into the sum of at least two positive integers, and maximize the product of those integers.

Return the maximum product achievable.

**Match**

This is a Dynamic Programming / DFS with memoization problem.
We recursively break down n into smaller subproblems:

For each possible split i + (n - i), we choose the one giving the maximum product.

Each split can either stop (take i and n - i as is) or continue breaking further.

Recursive structure:

dfs(num) = max(i _ (num - i), dfs(i) _ dfs(num - i)) for i in 1..num-1

We use memoization (@lru_cache) to avoid recomputation.

**Plan**

Define dfs(num) → maximum product achievable from integer num.

Base case:

If num == 1, return 1.

For each split i from 1 to num-1:

Compare product from directly splitting (i _ (num - i))
and recursive splitting (dfs(i) _ dfs(num - i)).

Take the maximum of all splits.

Return dfs(n).

**Implement**

```py
from functools import lru_cache

class Solution:
    def integerBreak(self, n: int) -> int:
        if n == 1:
            return 1

        @lru_cache()
        def dfs(num):
            if num == 1:
                return 1
            res = 0 if num == n else num
            for i in range(1, num):
                res = max(res, dfs(i) * dfs(num - i))
            return res

        return dfs(n)
```

**Review**

Uses recursion with memoization to explore all possible splits efficiently.

Base case ensures termination and correct handling of smallest number.

Avoids recomputation through caching of subproblems.

**Evaluate**

Time Complexity: O(n²), since each number up to n is split in all possible ways.

Space Complexity: O(n) for recursion depth + memoization cache.

**Pattern to remember**

For integer partition / maximize product problems:

Use DFS or DP to explore all possible splits.

Cache intermediate results (@lru_cache).

Be careful to exclude the original number itself (res = 0 if num == n).
