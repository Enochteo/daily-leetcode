## Maximum Length of Increasing Subarrays

**Understand**

You are given an integer array nums.
Find the maximum integer k such that there exist two consecutive non-overlapping increasing subarrays each of length at least k.

An increasing subarray means every consecutive element satisfies:

nums[i] < nums[i+1]

**Example**:

```
Input: nums = [1,2,3,2,3,4,5,6]
Output: 3
Explanation:
- Increasing subarrays: [1,2,3] and [2,3,4,5,6]
- Largest `k` where both consecutive increasing subarrays have at least length `k` = 3
```

**Edge Case Example**:

```
Input: nums = [5,4,3,2,1]
Output: 1
Explanation:
No increasing subarrays longer than 1 exist.
```

**Match**

This is a pattern-tracking problem — similar to “Longest Increasing Subsequence,” but instead of one sequence, we track pairs of consecutive increasing runs.

We can solve this using a linear scan with counters for:

Current increasing streak (count)

Previous streak (adj_count)

Global maximum k (max_k)

**Plan**

Initialize:

count = 1 → current increasing run length

adj_count = 0 → previous increasing run length

max_k = 1 → current best value of k

Iterate over the array:

If nums[i] > nums[i - 1], increment count.

Otherwise, the increasing streak ends:

Update max_k with max(max_k, min(adj_count, count)) (best overlap between consecutive runs).

Also check count // 2 for isolated long streaks.

Set adj_count = count and reset count = 1.

After iteration, repeat the final max_k updates for the last streak.

Return max_k.

**Implement**

```py
class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        count, adj_count, max_k = 1, 0, 1
        for i in range(1, len(nums)):
            if nums[i] > nums[i-1]:
                count += 1
            else:
                max_k = max(max_k, count // 2)
                max_k = max(max_k, min(adj_count, count))
                adj_count = count
                count = 1
        max_k = max(max_k, count // 2)
        max_k = max(max_k, min(adj_count, count))
        return max_k
```

**Review**

Efficiently tracks increasing streaks in one pass.

Compares adjacent run lengths to determine maximum valid k.

Handles both isolated and chained increasing sequences.

Works correctly for arrays with uniform, decreasing, or mixed patterns.

**Evaluate**

Time Complexity: O(n) — single pass through the array.

Space Complexity: O(1) — uses constant auxiliary variables.

**Pattern to remember**

For consecutive segment comparison problems:

Maintain length counters for current and previous runs.

Compare adjacent streaks using min(prev, curr) for valid overlap-based metrics.

Always perform a final update after the loop for tail sequences.
