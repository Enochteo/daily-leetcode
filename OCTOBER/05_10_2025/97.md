## Interleaving String

**Understand**
Given three strings s1, s2, s3, return whether or not the string s3 can be formed by interleaving the string s1 and s2. An interleaving of two strings s and t is a configuration where s and t are divided into n and m substrings respectively, such that:

```
s = s1 + s2 + ... + sn
t = t1 + t2 + ... + tm
|n - m| <= 1
The interleaving is s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ...
Note: a + b is the concatenation of strings a and b.
```

**Match**
This is a dynamic programming question, but could also be solved using recursive backtracking with memoization for optimization.
The subproblem is to track the current string index in s3 and decide whether or not to take s1 or s2:

```
take1 -> res + s1
take2 -> res + s2

return take1 == s3 or take2 == s3
```

**Plan**

- Initialize memo
- the good base case is when both indexes reach the end and are equal to the length of s3
- the bad base case is when the indexes are greater than s3
- initialize take1 and take2 to False
- check if the current of string one matches the condition (index1 < len(s1) and s1[index1] == s3[index1 + index2])
- check also for string2
- return whether or not either of both match the case

**Implement**

```py
class Solution:
    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:
        memo = {}
        def dfs(index1, index2):
            if index1 == len(s1) and index2 == len(s2) and index1 + index2 == len(s3):
                return True
            if index1 + index2 >= len(s3):
                return False
            if (index1, index2) in memo:
                return memo[(index1, index2)]

            take1, take2 = False, False
            if index1 < len(s1) and s1[index1] == s3[index1 + index2]:
                take1 = dfs(index1 + 1, index2)

            if index2 < len(s2) and s2[index2] == s3[index1 + index2]:
                take2 = dfs(index1, index2 + 1)

            memo[(index1, index2)] = take1 or take2
            return take1 or take2
        return dfs(0, 0)
```

**Review**

- It works for strings whos length do not match for the resulting string s3
- It also catches empty strings and when emptry strings are matched with non-empty string

**Evaluate**

- The time complexity is O(N + M) where N is the length of s1 and M is the length of s2
- The space complexity is O(N+M) for the call stack
