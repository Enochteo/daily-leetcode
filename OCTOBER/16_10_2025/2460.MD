## Apply Operations to an Array

**Understand**

You are given an integer array nums.
Perform the following operations in order:

For each index i, if nums[i] == nums[i + 1], then:

Double nums[i] (i.e., nums[i] \*= 2)

Set nums[i + 1] = 0

After processing all elements, move all zeros to the end of the array while maintaining the relative order of the non-zero elements.

Return the final array.

**Match**

This is a simulation and in-place array manipulation problem.
It combines two common patterns:

Adjacent pair merging (similar to 2048-style merging).

Zero shifting (moving all zeros to the end).

**Plan**

Initialize a counter zeros = 0 for tracking zeros.

Iterate through nums:

If nums[i] == 0, increment zeros.

If current and next element are equal (nums[i] == nums[i+1]):

Double current (nums[i] \*= 2)

Set next to 0 (nums[i+1] = 0).

After processing, rebuild result array:

Collect all non-zero elements.

Append zeros number of zeros at the end.

Return the modified array.

**Implement**

```
class Solution:
    def applyOperations(self, nums: List[int]) -> List[int]:
        zeros = 0
        for i in range(len(nums)):
            if nums[i] == 0:
                zeros += 1
            if i == len(nums) - 1:
                break
            if nums[i] == nums[i+1]:
                nums[i] *= 2
                nums[i+1] = 0
        res = [n for n in nums if n != 0]
        for _ in range(zeros):
            res.append(0)
        return res
```

**Review**

Handles adjacent merges first, then reorders by filtering non-zero elements.

Correctly shifts zeros to the end while maintaining order of merged results.

Avoids index errors by stopping one step early in the loop.
