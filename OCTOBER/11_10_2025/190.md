## Reverse Bits

**Understand**

You are given a 32-bit unsigned integer n.
Your task is to reverse the bits of n and return the resulting integer.

Example:

```
Input: n = 00000010100101000001111010011100
Output:    964176192
Explanation: Reversed bits = 00111001011110000010100101000000
```

**Match**

This is a bit manipulation problem.
We process each bit in n from least significant bit (LSB) to most significant bit (MSB),
and build the reversed result by shifting bits accordingly.

**Plan**

Initialize res = 0.

Loop 32 times (since it’s a 32-bit integer):

Shift res left by 1 to make space for the next bit.

Extract the lowest bit of n → n & 1.

Add that bit to res.

Shift n right by 1 to move to the next bit.

Return the final res.

Initialize res = 0.

Loop 32 times (since it’s a 32-bit integer):

Shift res left by 1 to make space for the next bit.

Extract the lowest bit of n → n & 1.

Add that bit to res.

Shift n right by 1 to move to the next bit.

Return the final res.

**Implement**

```py
class Solution:
    def reverseBits(self, n: int) -> int:
        res = 0
        for _ in range(32):
            res = res << 1          # shift result left to make space
            msb = n & 1             # extract lowest bit of n
            res += msb              # add bit to result
            n = n >> 1              # shift n right to process next bit
        return res
```

**Review**

Processes exactly 32 bits regardless of the input value.

Shifting ensures proper bit reversal order.

Handles unsigned integers correctly (Python integers are unbounded, but we treat n as 32-bit).

**Evaluate**

Time Complexity: O(32) → constant time.

Space Complexity: O(1) → uses fixed variables only.

**Pattern to remember**

For bit reversal problems:

Use bitwise operations:

& 1 to extract lowest bit.

<< and >> for shifting.

Repeat for a fixed bit-width (32 for unsigned int).

Accumulate bits into result in reversed order.
