## Linked List in Binary Tree

**Understand**

We are given:

A linked list head.

A binary tree root.

We must determine if the linked list is a downward path in the binary tree.

The path must start at some tree node.

The path must follow left/right child pointers.

Each tree node must match the corresponding list node.

```
Example:

Input: head = [4,2,8], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]
Output: True
Explanation: Linked list [4,2,8] exists as a downward path in the tree.
```

Constraints:

Length of linked list: 1 <= n <= 100

Nodes in binary tree: 1 <= m <= 2500

**Match**

This is a tree + linked list pattern matching problem.

Use DFS to try every tree node as a potential starting point.

When values match, recursively check if the linked list continues down that subtree.

Otherwise, keep searching left and right.

**Plan**

Define linked_list_exists(head, root) to check if linked list starting at head matches a path starting at tree node root:

If head == None → return True (list fully matched).

If root == None → return False.

If values differ → return False.

Otherwise, recurse to left and right children with head.next.

Define dfs(llist, tree) to search tree:

If llist == None → return True.

If tree == None → return False.

If values match and linked_list_exists(llist, tree) returns True → return True.

Otherwise, recurse dfs into tree.left and tree.right.

Return result of dfs(head, root).

**Implement**

```py
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:
        def dfs(llist, tree):
            if not llist:
                return True
            if not tree:
                return False
            cur = False
            if llist.val == tree.val:
                if linked_list_exists(llist, tree):
                    cur = True
            return cur or dfs(llist, tree.left) or dfs(llist, tree.right)

        def linked_list_exists(head, root):
            if not head:
                return True
            if not root:
                return False
            if root.val != head.val:
                return False
            return linked_list_exists(head.next, root.left) or linked_list_exists(head.next, root.right)

        return dfs(head, root)
```

**Review**

dfs explores every node in the binary tree as a potential starting point.

linked_list_exists validates continuation of linked list along a downward path.

Returns True if any valid path matches.
