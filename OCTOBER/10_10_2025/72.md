## Edit Distance

**Understand**

You are given two strings, word1 and word2.
You must find the minimum number of operations required to convert word1 into word2.

Allowed operations:

Insert a character

Delete a character

Replace a character

**Example**:

```
Input: word1 = "horse", word2 = "ros"
Output: 3
Explanation:
horse → rorse (replace 'h' → 'r')
rorse → rose  (remove 'r')
rose  → ros   (remove 'e')

Input: word1 = "intention", word2 = "execution"
Output: 5
```

**Match**

This is a Dynamic Programming problem (Levenshtein distance).
We use DFS + memoization to compute the minimal edit cost between substrings.

Key subproblem:
dfs(i, j) = minimum edits to convert word1[i:] → word2[j:]

Transition:

If characters match → move diagonally with no cost.

Otherwise, we consider three possibilities:

Replace: dfs(i+1, j+1)

Delete: dfs(i+1, j)

Insert: dfs(i, j+1)

We take the minimum of these three options + 1 operation.

**Plan**

Define recursive function dfs(i, j) → min operations from word1[i:] to word2[j:].

Base cases:

If i == len(word1) → remaining characters of word2 must be inserted → len(word2) - j.

If j == len(word2) → remaining characters of word1 must be deleted → len(word1) - i.

If characters match, no operation is needed → move diagonally.

Otherwise, compute the minimum among replace, insert, delete.

Use memoization to cache results for (i, j).

Return dfs(0, 0) as final answer.
