## Edit Distance

**Understand**

You are given two strings, word1 and word2.
You must find the minimum number of operations required to convert word1 into word2.

Allowed operations:

Insert a character

Delete a character

Replace a character

**Example**:

```
Input: word1 = "horse", word2 = "ros"
Output: 3
Explanation:
horse → rorse (replace 'h' → 'r')
rorse → rose  (remove 'r')
rose  → ros   (remove 'e')

Input: word1 = "intention", word2 = "execution"
Output: 5
```

**Match**

This is a Dynamic Programming problem (Levenshtein distance).
We use DFS + memoization to compute the minimal edit cost between substrings.

Key subproblem:
dfs(i, j) = minimum edits to convert word1[i:] → word2[j:]

Transition:

If characters match → move diagonally with no cost.

Otherwise, we consider three possibilities:

Replace: dfs(i+1, j+1)

Delete: dfs(i+1, j)

Insert: dfs(i, j+1)

We take the minimum of these three options + 1 operation.

**Plan**

Define recursive function dfs(i, j) → min operations from word1[i:] to word2[j:].

Base cases:

If i == len(word1) → remaining characters of word2 must be inserted → len(word2) - j.

If j == len(word2) → remaining characters of word1 must be deleted → len(word1) - i.

If characters match, no operation is needed → move diagonally.

Otherwise, compute the minimum among replace, insert, delete.

Use memoization to cache results for (i, j).

Return dfs(0, 0) as final answer.

**Implement**

```py
class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        memo = {}

        def dfs(index1, index2):
            if index1 == len(word1):
                return len(word2) - index2
            if index2 == len(word2):
                return len(word1) - index1
            if (index1, index2) in memo:
                return memo[(index1, index2)]

            if word1[index1] == word2[index2]:
                memo[(index1, index2)] = dfs(index1 + 1, index2 + 1)
                return memo[(index1, index2)]

            memo[(index1, index2)] = 1 + min(
                dfs(index1 + 1, index2 + 1),  # replace
                dfs(index1 + 1, index2),      # delete
                dfs(index1, index2 + 1)       # insert
            )
            return memo[(index1, index2)]

        return dfs(0, 0)
```

**Review**

Efficiently avoids recomputation using memoization.

Covers all edit operations recursively.

Handles different string lengths cleanly via base cases.

**Evaluate**

Time Complexity: O(m × n), since each (i, j) state is computed once.

Space Complexity: O(m × n) for memoization + recursion stack.

**Pattern to remember**

For edit distance / string transformation problems:

Use recursion or DP on indices (i, j) of both strings.

Base case handles when one string is exhausted.

Transition considers insert, delete, replace — take min + 1.

Memoize overlapping subproblems for efficiency.