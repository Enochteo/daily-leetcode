## Unique Paths

**Understand**

You are given an m x n grid.
A robot starts at the top-left corner (0, 0) and can only move down or right at each step.
The goal is to reach the bottom-right corner (m - 1, n - 1).

Return the total number of unique paths possible.

**Match**

This is a combinatorial path counting or Dynamic Programming (DFS + memoization) problem.

Each cell (r, c) can move to (r+1, c) or (r, c+1).

The total paths from (r, c) = sum of paths from its right and bottom neighbors.

Use memoization to avoid recomputing overlapping subproblems.

Recursive relation:

dfs(r, c) = dfs(r + 1, c) + dfs(r, c + 1)
Base cases:

- If out of bounds → 0
- If at destination → 1

**Plan**

Define a recursive dfs(r, c) that returns the number of paths from (r, c) to the bottom-right corner.

Base cases:

If r >= m or c >= n → return 0 (out of bounds).

If (r, c) is destination (m-1, n-1) → return 1.

Use memoization (memo[(r, c)]) to store results.

For each cell, compute:

```
dfs(r, c) = dfs(r + 1, c) + dfs(r, c + 1)
```

Return dfs(0, 0) as the total number of unique paths.

**Implement**

```py
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        memo = {}
        def dfs(r, c):
            if r >= m or c >= n:
                return 0
            if r == m - 1 and c == n - 1:
                return 1
            if (r, c) in memo:
                return memo[(r, c)]
            memo[(r, c)] = dfs(r + 1, c) + dfs(r, c + 1)
            return memo[(r, c)]
        return dfs(0, 0)
```

**Review**

Recursively explores both possible moves.

Memoization avoids redundant recalculations for overlapping subproblems.

Clean and intuitive top-down DP formulation.

**Evaluate**

Time Complexity: O(m × n), since each cell (r, c) is computed once.

Space Complexity: O(m × n) for memoization and recursion stack.

**Pattern to remember**

For grid traversal problems with directional movement (down/right):

Use recursion or DP with state (r, c).

Base case: destination = 1, out of bounds = 0.

Transition: dp[r][c] = dp[r+1][c] + dp[r][c+1].

Memoize or tabulate to ensure O(m × n) efficiency.
