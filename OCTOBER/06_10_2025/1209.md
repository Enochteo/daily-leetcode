## Remove All Adjacent Duplicates in String II

**Understand**

You are given a string s and an integer k.
You must repeatedly remove k adjacent duplicate characters until no more such groups exist.

Example:

````
Input: s = "deeedbbcccbdaa", k = 3
Output: "aa"
Explanation:
- Remove "eee" → "ddbbcccbdaa"
- Remove "ccc" → "ddbbbdaa"
- Remove "bbb" → "dddaa"
- Remove "ddd" → "aa"
```
````

**Match**

This is a stack-based problem that tracks character frequencies.

Each stack entry holds (char, count) representing consecutive duplicates.

If count == k, that run is removed.

Efficiently simulates cascading removals in one pass.

**Plan**

Initialize an empty stack.

For each character c in s:

If stack not empty and top character equals c:

Increment its count.

If new count equals k, pop it (remove k duplicates).

Else, push (c, 1) onto stack.

Rebuild final string from remaining (char, count) pairs.

**Implement**

```py
class Solution:
    def removeDuplicates(self, s: str, k: int) -> str:
        stack = []
        for c in s:
            if stack and c == stack[-1][0]:
                char, count = stack.pop()
                if count + 1 != k:
                    stack.append((char, count + 1))
            else:
                stack.append((c, 1))
        res = ''
        for char, count in stack:
            res += char * count
        return res
```

**Review**

Stack tracks both characters and their consecutive counts.

Popping when count == k effectively removes k duplicates at once.

Handles cascading removals naturally as stack evolves.

**Evaluate**

Time Complexity: O(n), each character is pushed/popped at most once.

Space Complexity: O(n) for stack storage (worst case no removals).

**Pattern to remember**

For adjacent duplicate removals with threshold k:

Use a stack storing (char, count) pairs.

Increment counts on match, pop when count == k.

Rebuild the final string from remaining stack pairs.
