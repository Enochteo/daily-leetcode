## Find Increasing Subarrays

**Understand**

You are given an integer array nums and an integer k.
Return True if there exist two consecutive non-overlapping increasing subarrays, each of length k.
Otherwise, return False.

Each increasing subarray must satisfy:

nums[i] < nums[i + 1] < ... < nums[i + k - 1]

and the second subarray must immediately follow the first one.

Example:

Input: nums = [1,2,3,5,6,7,8,9], k = 3
Output: True
Explanation:
Two consecutive increasing subarrays of length 3 are:
[1,2,3] and [5,6,7]

Input: nums = [1,2,1,2,3,4], k = 2
Output: False
Explanation:
There are increasing pairs, but none are consecutive non-overlapping segments of equal length.

**Match**

This is a subarray pattern detection problem using window checking.
We need to scan the array and check, for every starting index i, whether both segments [i:i+k] and [i+k:i+2k] are strictly increasing.

**Plan**

Define a helper function hIS(index) that checks if two consecutive increasing subarrays of length k start at index.

If index + 2k > len(nums), return False (out of bounds).

Check that both [index : index + k] and [index + k : index + 2k] are strictly increasing.

Iterate through nums from index 0 to len(nums) - 2k.

If any hIS(i) returns True, return True.

Return False if no valid position is found.

**Implement**

```
class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        def hIS(index):
            if index + (k * 2) > len(nums):
                return False
            for i in range(1, k):
                if nums[index + i] <= nums[index + i - 1]:
                    return False
            for i in range(1, k):
                if nums[index + k + i] <= nums[index + k + i - 1]:
                    return False
            return True
        for i in range(len(nums)):
            if hIS(i):
                return True
        return False
```

**Review**

Checks increasing order for both consecutive subarrays of length k.

Early returns when a valid pattern is found.

Simple and clear structure with boundary guard conditions.

**Evaluate**

Time Complexity: O(n × k) — each starting index checks two windows of size k.

Space Complexity: O(1) — only a few constant variables used.

**Pattern to remember**

For pattern-based subarray detection problems:

Use a sliding window or helper to validate local subarray properties.

Check edge bounds early to avoid out-of-range errors.

Early return once condition is met to avoid unnecessary computation.
