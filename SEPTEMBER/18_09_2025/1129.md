## Shortest Path with Alternating Colors
**Understand**

We are given a directed graph with n nodes labeled 0..n-1. Edges are either red or blue.

We want the shortest distance from node 0 to every node such that the path alternates edge colors.

If no such path exists, return -1 for that node.

**Match**

This is a BFS shortest path problem with stateful traversal.

State includes (node, last_color) to enforce alternating edges.

BFS ensures shortest path discovery.

Use a visited set to avoid revisiting (node, color) states.

**Plan**

Build adjacency list adj[node] = [(nei, color)].

Initialize queue with (0, None) since we can start with any edge color.

Maintain dist array initialized to -1.

BFS with steps counter:

For each node at current level:

If dist[node] == -1, set it to steps.

For each (nei, color) in adjacency list:

If color != last_color and (nei, color) not visited â†’ enqueue.

Increment steps after each BFS layer.

Return dist.

**Implement**
```py
from collections import defaultdict, deque

class Solution(object):
    def shortestAlternatingPaths(self, n, redEdges, blueEdges):
        """
        :type n: int
        :type redEdges: List[List[int]]
        :type blueEdges: List[List[int]]
        :rtype: List[int]
        """
        adj = defaultdict(list)
        for node, nei in redEdges:
            adj[node].append((nei, 'r'))
        for node, nei in blueEdges:
            adj[node].append((nei, 'b'))
        
        q = deque([(0, None)])
        visited = {(0, None)}   
        dist = [-1] * n
        steps = 0
        
        while q:
            for _ in range(len(q)):
                cur, cur_color = q.popleft()
                if dist[cur] == -1:
                    dist[cur] = steps
                for nei, color in adj[cur]:
                    if cur_color != color and (nei, color) not in visited:
                        q.append((nei, color))
                        visited.add((nei, color))
            steps += 1
        return dist
```