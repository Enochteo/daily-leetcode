## Fruit Into Baskets
**Understand**

We are given an array fruits where each element represents a type of fruit on a tree. We have two baskets, and each basket can only hold one type of fruit. We want the length of the longest contiguous subarray that contains at most two distinct fruit types.

**Example**:
```
Input: fruits = [1,2,1]
Output: 3
Explanation: Take all 3 trees â†’ types {1,2}.

```
**Constraints**:

1 <= fruits.length <= 10^5

0 <= fruits[i] < fruits.length

**Match**

This is a sliding window problem with at most 2 distinct values.

Maintain a window with two fruit types.

Expand window by moving right pointer.

Shrink from the left when window exceeds 2 fruit types.

**Plan**

Initialize l = 0, max_len = 0, and window_counter as a hashmap to count fruits in window.

Iterate r over fruits:

Add fruits[r] to window_counter.

While more than 2 distinct fruits:

Decrement count of fruits[l].

If count becomes 0, remove from map.

Increment l to shrink window.

Update max_len = max(max_len, r - l + 1).

Return max_len.

**Implement**
```py
from collections import defaultdict

class Solution(object):
    def totalFruit(self, fruits):
        """
        :type fruits: List[int]
        :rtype: int
        """
        max_len = 0
        l = 0
        window_counter = defaultdict(int)
        
        for r in range(len(fruits)):
            window_counter[fruits[r]] += 1
            while len(window_counter) > 2:
                window_counter[fruits[l]] -= 1
                if window_counter[fruits[l]] == 0:
                    del window_counter[fruits[l]]
                l += 1
            max_len = max(max_len, r - l + 1)
        
        return max_len
```

**Review**

Expands and shrinks window dynamically.

Hashmap ensures only two fruit types in window.

Guarantees maximum subarray length is tracked.

**Evaluate**

Time Complexity: O(n), each index processed at most twice (enter + exit window).

Space Complexity: O(1), since at most 2 fruit types are stored in map.