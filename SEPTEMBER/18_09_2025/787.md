## Cheapest Flights Within K Stops
**Understand**

We are given:

n cities labeled 0..n-1,

flights flights[i] = [from, to, price],

a source src, a destination dst,

and a maximum number of stops k.

We must find the cheapest price from src to dst with at most k stops. If no route exists, return -1.

**Match**

This is a shortest path with constraint problem.

Standard Dijkstra must be adapted to limit paths to k stops.

Use a priority queue (cost, node, stops) to expand cheapest option first.

Track visited states to avoid unnecessary expansions.

**Plan**

Build adjacency list: adj[u] = [(v, cost), â€¦].

Use min-heap starting with (0, src, 0) (cost, node, stops used).

While heap not empty:

Pop (cur_cost, cur_node, stops).

If cur_node == dst, return cur_cost.

If stops <= k, expand neighbors:

Compute new_cost = cur_cost + edge_cost.

Push (new_cost, nei, stops+1) if beneficial.

If queue empties, return -1.