## Remove K Digits
**Understand**

We are given a string num representing a non-negative integer and an integer k. We must remove exactly k digits from num so that the new number is the smallest possible.
```
Example:

Input: num = "1432219", k = 3
Output: "1219"
```

**Match**

This is a monotonic stack problem.

To minimize the number, we want smaller digits earlier.

Iterate digits and maintain a non-decreasing stack.

Pop from stack while:

Top of stack > current digit, and

We still have removals left (k > 0).

After traversal, if removals remain, remove from the end.

**Plan**

Edge case: if k == len(num), return "0".

Initialize empty stack.

For each digit in num:

While stack not empty, top > digit, and k > 0:

Pop stack, decrement k.

Append current digit.

Build answer string from stack.

If k > 0, remove last k digits.

Convert to integer and back to string to remove leading zeros.

Return result, or "0" if empty.

**Implement**
```py
class Solution(object):
    def removeKdigits(self, num, k):
        """
        :type num: str
        :type k: int
        :rtype: str
        """
        if len(num) == k:
            return "0"
        stack = []
        for i in range(len(num)):
            if stack:
                while stack and stack[-1] > num[i] and k:
                    stack.pop()
                    k -= 1
            stack.append(num[i])
        ans = str(int("".join(stack)))
        if k:
            ans = ans[:-k]
            return ans if ans else "0"
        return ans
```

**Review**

Stack ensures digits are kept in non-decreasing order.

Removing from the back handles leftover k.

lstrip("0") ensures no leading zeros in result.

**Evaluate**

Time Complexity: O(n), where n = length of num. Each digit pushed and popped at most once.

Space Complexity: O(n) for the stack.