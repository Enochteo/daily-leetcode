## Next Permutation
**Understand**
Given an array nums, rearrange it into the next lexicographically greater permutation. If such arrangement isn’t possible (array is in descending order), rearrange it to the lowest possible order (sorted ascending). Operation must be in-place.

**Match**
Greedy + suffix manipulation:

Scan from right to find the first pivot where nums[i] > nums[i-1].

If no pivot, reverse entire array (it was the last permutation).

Otherwise, find the rightmost successor greater than the pivot in the suffix, swap, then reverse the suffix to get the minimal larger ordering.

**Plan**

Find pivot index p = i-1 from right where nums[i] > nums[i-1].

If pivot not found, reverse whole array and return.

From the end, find first swap index with nums[swap] > nums[pivot].

Swap nums[pivot] and nums[swap].

Reverse the suffix starting at pivot+1.

**Implement**
```py
class Solution(object):
    def nextPermutation(self, nums):
        """
        :type nums: List[int]
        :rtype: None Do not return anything, modify nums in-place instead.
        """
        pivot = None
        for i in range(len(nums)-1, 0, -1):
            if nums[i] > nums[i-1]:
                pivot = i - 1
                break
        else:
            nums.reverse()
            return
        
        swap = len(nums) - 1
        while nums[swap] <= nums[pivot]:
            swap -= 1
        nums[pivot], nums[swap] = nums[swap], nums[pivot]
        nums[pivot+1:] = reversed(nums[pivot+1:])
        return
``` 
**Review**

The for ... else correctly detects the “no pivot” case and reverses the entire array.

Choosing the rightmost successor ensures the smallest increase.

Reversing the suffix guarantees the next permutation is the smallest one larger than the original.

**Evaluate**

Time Complexity: O(n) (single right-to-left scan plus suffix reverse).

Space Complexity: O(1) extra (in-place operations).