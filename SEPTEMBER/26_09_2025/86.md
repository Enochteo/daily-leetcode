## Partition List
**Understand**

We are given the head of a linked list and an integer x.

We must reorder the list so that:

All nodes with value < x come before nodes with value >= x.

The relative order of nodes in each partition is preserved.

**Example**:
```
Input: head = [1,4,3,2,5,2], x = 3
Output: [1,2,2,4,3,5]
```

**Match**

This is a linked list partitioning problem.

Relative order must be preserved â†’ cannot just swap values.

Natural solution: build two lists (one for < x, one for >= x), then join them.

**Plan**

Create two dummy nodes: dummy_less, dummy_greater.

Use less pointer to build list of nodes < x.

Use greater pointer to build list of nodes >= x.

Traverse original list:

If cur.val < x, append to less.

Else append to greater.

At the end:

Connect less.next = dummy_greater.next.

Set greater.next = None to terminate properly.

Return dummy_less.next.

**Implement**
```py
# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution(object):
    def partition(self, head, x):
        """
        :type head: Optional[ListNode]
        :type x: int
        :rtype: Optional[ListNode]
        """
        less = dummy_less = ListNode(-300)
        greater = dummy_greater = ListNode(300)
        cur = head
        
        while cur:
            if cur.val < x:
                less.next = cur
                less = less.next
            else:
                greater.next = cur
                greater = greater.next
            cur = cur.next
        
        greater.next = None
        less.next = dummy_greater.next
        return dummy_less.next
```

**Review**

Dummy heads simplify edge cases (empty partitions).

greater.next = None prevents cycle.

Concatenation preserves relative order.

Evaluate

Time Complexity: O(n), single pass through list.

Space Complexity: O(1), only uses pointers.

**Pattern to remember**

For partitioning a linked list around a value while preserving order:

Use two dummy lists (< x, >= x).

Append nodes accordingly.

Concatenate at the end.