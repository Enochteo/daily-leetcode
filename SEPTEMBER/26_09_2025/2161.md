## Partition Array According to Given Pivot

**Understand**

We are given an integer array nums and an integer pivot.

We need to rearrange nums such that:

All elements less than pivot appear before elements equal to pivot.

Elements equal to pivot come before elements greater than pivot.

The relative order of elements in each group must be preserved.

**Example**:
```
Input: nums = [9,12,5,10,14,3,10], pivot = 10
Output: [9,5,3,10,10,12,14]
```

Constraints:

1 <= nums.length <= 10^5

-10^6 <= nums[i] <= 10^6

**Match**

This is a stable partitioning problem.

We need three groups: < pivot, == pivot, > pivot.

A straightforward approach is to build three separate lists and concatenate.

**Plan**

Initialize three lists: less, equal, greater.

Traverse nums:

If n < pivot → append to less.

If n == pivot → append to equal.

Else append to greater.

Concatenate less + equal + greater.

Return the result.

**Implement**
```py
class Solution(object):
    def pivotArray(self, nums, pivot):
        """
        :type nums: List[int]
        :type pivot: int
        :rtype: List[int]
        """
        less = []
        greater = []
        equal = []

        for n in nums:
            if n < pivot:
                less.append(n)
            elif n > pivot:
                greater.append(n)
            else:
                equal.append(n)
        return less + equal + greater
```
**Review**

Preserves relative order by appending in traversal order.

Simple and clear implementation.

Concatenation at the end yields correct arrangement.

**Evaluate**

Time Complexity: O(n), single pass through array.

Space Complexity: O(n), additional lists for groups.

**Pattern to remember**

For partitioning around a pivot while preserving stability:

Collect elements into three lists: less, equal, greater.

Concatenate in required order.

Alternative: in-place partition with careful swaps (less memory).