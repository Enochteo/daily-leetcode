## Find Eventual Safe States
**Understand**

We are given a directed graph where graph[i] is the list of nodes that node i points to.

A node is eventually safe if every possible path starting from that node ends in a terminal node (a node with no outgoing edges), i.e., no path leads into a cycle.

We must return all safe nodes in ascending order.

**Match**

This is a graph cycle detection problem.

Unsafe nodes are those that are part of or lead into cycles.

Use DFS with recursion + visited set to detect cycles.

Maintain two sets:

safe: nodes proven to be safe.

unsafe: nodes proven to be unsafe.

**Plan**

Define helper hasCycle(node, visit) that returns True if node leads to a cycle:

If node in visit or unsafe → return True.

If node in safe → return False.

Recurse for neighbors with updated path set.

If any neighbor leads to a cycle → mark unsafe and return True.

Otherwise, mark node safe and return False.

Iterate through all nodes 0..n-1.

If hasCycle(node) returns False, add node to result.

Return result.

**Implement**
```py
class Solution(object):
    def eventualSafeNodes(self, graph):
        """
        :type graph: List[List[int]]
        :rtype: List[int]
        """
        n = len(graph)
        unsafe = set()
        safe = set()
        res = []
        
        def hasCycle(node, visit):
            if node in visit or node in unsafe:
                return True
            if node in safe:
                return False
            for nei in graph[node]:
                if hasCycle(nei, visit | {node}):
                    unsafe.add(nei)
                    return True
            safe.add(node)
            return False
        
        for i in range(n):
            if hasCycle(i, set()):
                unsafe.add(i)
            else:
                res.append(i)
        return res
```