## LRU Cache
**Understand**

We need to design a Least Recently Used (LRU) cache that supports two operations in O(1) time:

get(key): return value if key exists, else -1.

put(key, value): insert or update value, and evict the least recently used key if capacity is exceeded.

**Match**

This is a data structure design problem requiring:

Fast key lookup → hash map (dictionary).

Fast updates to recency order → doubly linked list.

Pattern:

Maintain DLL with most recently used nodes near RIGHT sentinel and least near LEFT.

Hash map stores key → node for O(1) access.

**Plan**

Define a doubly-linked ListNode class with (key, val, prev, next).

LRUCache maintains:

cache dict: maps key → node.

capacity.

Two sentinels LEFT (LRU) and RIGHT (MRU).

Add node: insert at RIGHT.prev.

Remove node: unlink from DLL.

get(key):

If key not in cache → return -1.

Else remove node and add it back near RIGHT.

put(key, value):

If key exists, remove old node.

Add new node near RIGHT.

If size exceeds capacity, remove LEFT.next and evict from cache.