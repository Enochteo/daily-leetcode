## Network Delay Time
**Understand**

We are given a directed weighted graph with n nodes (labeled 1..n) and a list times where each element is [u, v, w] meaning there is a signal edge from node u to node v taking w time.

We start at node k and need to calculate how long it takes for all nodes to receive the signal.

If all nodes can be reached, return the maximum time among shortest paths from k.

If some nodes can’t be reached, return -1.

**Match**

This is a shortest path problem in a weighted directed graph.

Best-fit algorithm: Dijkstra’s algorithm (since weights are non-negative).

We use a min-heap priority queue to always expand the shortest distance node next.

**Plan**

Build adjacency list: for each (u, v, w) in times, store (v, w) in adj[u].

Initialize distances array with inf, except distances[k-1] = 0.

Use a min-heap q storing (node, current_distance). Push (k, 0).

While heap not empty:

Pop (curr, distance).

For each neighbor (nei, weight):

If distance + weight < distances[nei-1]: update distances[nei-1] and push (nei, new_distance).

After traversal:

If any distance is inf, return -1 (some nodes unreachable).

Otherwise return max(distances) as total time.

**Implement**
```
import heapq
from collections import defaultdict

class Solution:
    def networkDelayTime(self, times: List[List[int]], n: int, k: int) -> int:
        adj = defaultdict(list)
        for source, dest, time in times:
            adj[source].append((dest, time))
        
        distances = [float('inf')] * n
        distances[k - 1] = 0
        
        q = [(0, k)]  # (distance, node)
        
        while q:
            distance, curr = heapq.heappop(q)
            if distance > distances[curr - 1]:
                continue
            for nei, weight in adj[curr]:
                new_dist = distance + weight
                if new_dist < distances[nei - 1]:
                    distances[nei - 1] = new_dist
                    heapq.heappush(q, (new_dist, nei))
        
        max_dist = max(distances)
        return max_dist if max_dist != float('inf') else -1
```

**Review**

Correctly applies Dijkstra’s algorithm with a min-heap.

Prevents reprocessing nodes with longer distances (if distance > distances[curr-1]: continue).

Fix: in your code, you pushed (k, 0) as (node, dist) but popped it as (curr, distance). That was inverted. It should be (dist, node) consistently.