## Design Add and Search Words Data Structure
**Understand**

We need to design a data structure that supports two operations:

addWord(word) – add a word to the structure.

search(word) – return true if the word exists, with the ability to use . as a wildcard that matches any single character

**Match**

This is a trie (prefix tree) problem with support for wildcard search.

Trie efficiently stores words character by character.

For search:

If normal character: follow child node.

If .: recursively check all children.

**Plan**

Implement a TrieNode with:

children: dict for next letters.

isEnd: boolean for word ending.

addWord(word):

Traverse trie, inserting nodes if missing.

Mark end node as word end.

search(word):

Define recursive helper backtrack(index, node).

If index == len(word): return node.isEnd.

If word[index] == '.': try all children recursively.

Else: follow the matching child if it exists.

Return whether a valid path exists.

**Implement**
```py
class TrieNode():
    def __init__(self):
        self.children = {}
        self.isEnd = False

class WordDictionary(object):
    def __init__(self):
        self.root = TrieNode()
        
    def addWord(self, word):
        """
        :type word: str
        :rtype: None
        """
        cur = self.root
        for c in word:
            if c not in cur.children:
                cur.children[c] = TrieNode()
            cur = cur.children[c]
        cur.isEnd = True
    
    def search(self, word):
        """
        :type word: str
        :rtype: bool
        """
        def backtrack(index, node):
            if index == len(word):
                return node.isEnd

            if word[index] == '.':
                for ch in node.children:
                    if backtrack(index+1, node.children[ch]):
                        return True
                return False
            else:
                if word[index] not in node.children:
                    return False
                return backtrack(index+1, node.children[word[index]])
        
        return backtrack(0, self.root)
```

**Review**

Correctly supports adding and searching words.

Wildcard search checks all children when encountering ..

Recursive search is clean and efficient.

**Evaluate**

Time Complexity:

addWord: O(L), where L = word length.

search: Worst case O(26^L) when many . are used, but typically much faster.

Space Complexity: O(T), where T = total characters in all inserted words.