## Longest Increasing Subsequence

**Understand**

We are given an array nums and must find the length of the longest strictly increasing subsequence (LIS).

A subsequence is formed by deleting some or no elements without changing the relative order.

Increasing means each subsequent element is greater than the previous one.

```
Example:

Input: nums = [10,9,2,5,3,7,101,18]
Output: 4
Explanation: LIS = [2,3,7,101]
```

**Constraints**:

1 <= nums.length <= 2500

-10^4 <= nums[i] <= 10^4

**Match**

This is a dynamic programming problem.

For each index i, LIS length starting at i depends on valid choices j > i with nums[j] > nums[i].

**Recurrence**:

dp[i] = 1 + max(dp[j]) for j > i and nums[j] > nums[i]

Otherwise, dp[i] = 1 (itself only).

**Plan**

Initialize dp[i] = 1 for all i.

Iterate i from right to left.

For each i, iterate j from i+1..n-1:

If nums[j] > nums[i], update dp[i] = max(dp[i], 1 + dp[j]).

Answer is max(dp).

**Implement**

```py
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        n = len(nums)
        dp = [1] * n

        for i in range(n - 1, -1, -1):
            for j in range(i + 1, n):
                if nums[j] > nums[i]:
                    dp[i] = max(dp[i], 1 + dp[j])
        return max(dp)
```

**Review**

Iterating backwards ensures dp[j] is already computed.

dp[i] accumulates LIS length starting at i.

Final answer = global max of dp.

**Evaluate**

Time Complexity: O(n²), double loop over pairs.

Space Complexity: O(n), DP array.

Optimized solution exists using patience sorting + binary search in O(n log n).

**Pattern to remember**

For LIS with O(n²) DP:

Define dp[i] as LIS starting at i.

Update using future indices j > i with nums[j] > nums[i].

Answer = max(dp)
