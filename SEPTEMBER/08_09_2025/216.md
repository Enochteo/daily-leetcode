## Combination Sum III
**Understand**

We are asked to find all possible combinations of k numbers that add up to n, using numbers from 1–9.

Each number can be used at most once.

The combinations should be unique.

Order doesn’t matter ([1,2,3] is the same as [3,2,1]).

**Example**:

Input: k = 3, n = 7
Output: [[1,2,4]]


Only one valid combination: 1 + 2 + 4 = 7.

Constraints:

2 <= k <= 9

1 <= n <= 60

**Match**

This is a backtracking / DFS problem.
We explore candidates (1–9), track the running sum and path, and prune early if:

The sum exceeds n.

The path length exceeds k.

Key idea: controlled recursion with pruning.

**Plan**

Maintain a path list for the current combination.

Start recursion from index=1 to 9.

At each step:

If sum(path) > n: stop (prune).

If len(path) == k:

Check if sum(path) == n, then save a copy.

Otherwise, iterate from index to 9, append the candidate, recurse, and backtrack.

Return all stored results.

**Implement**
```py
class Solution(object):
    def combinationSum3(self, k, n):
        """
        :type k: int
        :type n: int
        :rtype: List[List[int]]
        """
        res = []
        path = []

        def backtrack(index):
            if sum(path) > n:  # prune
                return
            if len(path) == k:
                if sum(path) == n:
                    res.append(path[:])
                return
            for i in range(index, 10):  # numbers 1–9
                path.append(i)
                backtrack(i + 1)  # move forward
                path.pop()

        backtrack(1)
        return res
```

**Review**

Time Complexity: O(C(9, k)) at most, since we are choosing k numbers from [1–9].

Space Complexity: O(k) recursion depth + result storage.

Pruning avoids unnecessary exploration when sum(path) > n.

**Evaluate**

Handles edge cases:

k = 3, n = 9 → [[1,2,6],[1,3,5],[2,3,4]]

k = 4, n = 1 → [] (impossible)

k = 9, n = 45 → [[1,2,3,4,5,6,7,8,9]]

The backtracking solution is correct, efficient, and easy to extend.