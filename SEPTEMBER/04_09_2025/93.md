## Restore IP Addresses
**Understand**
Given a string s containing only digits, return all possible valid IP addresses that can be formed by inserting three dots into s.
Validity rules for each of the 4 segments:

Value in [0, 255].

No leading zeros unless the segment is exactly "0" (e.g., "0", "10" valid; "00", "01" invalid).

**Match**
Backtracking: build segments left-to-right, trying segment lengths 1â€“3, pruning when a segment would be >255 or would start with '0' and have length >1. Track how many segments (dots) have been placed and the current index.

**Plan**

Recurse with parameters (index, dots, ip_string).

If dots == 4 and index == len(s), we have a valid IP; append it (trim trailing dot).

If dots > 4, backtrack.

Try segment ends i from index to min(index+2, len(s)-1):

Convert s[index:i+1] to int and ensure â‰¤ 255.

Leading-zero rule: allow '0' only if the segment length is 1.

If valid, recurse from i+1 with dots+1.

**Implement**
```py
class Solution(object):
    def restoreIpAddresses(self, s):
        """
        :type s: str
        :rtype: List[str]
        """
        res = []
        def backtrack(index, dots, ip):
            if dots == 4 and index == len(s):
                res.append(ip[:-1])
                return
            if dots > 4:
                return
            for i in range(index, min(index + 3, len(s))):
                if int(s[index:i+1]) <= 255 and (i==index or s[index] != '0'):
                    backtrack(i+1, dots + 1, ip + s[index:i+1] + '.')
        backtrack(0, 0, '')
        return res
```

**Review**

Tries at most 3 chars per segment and respects 0-leading constraint via (i == index or s[index] != '0').

Uses dots to ensure exactly 4 segments.

Appends a final IP by trimming the trailing '.'.

Note: For very long s, additional pruning (like ensuring remaining length fits into remaining segments) can speed up, but the logic is correct.