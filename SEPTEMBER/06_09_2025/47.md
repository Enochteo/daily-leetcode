## Permutations II
**Understand**
We’re asked to generate all unique permutations of nums, which may contain duplicates.

If we naïvely permute and store results in a set, it’s inefficient. Instead, we avoid duplicates directly during recursion by keeping track of how many of each number remain.

**Match**
Backtracking with frequency map (Counter):

At each step, choose a number that still has a positive count.

Append it to the current permutation, decrement its count, recurse.

Backtrack: pop and restore the count.

Stop when the permutation length equals len(nums).

**Plan**

Count occurrences of each number with Counter(nums).

Maintain a list perm for the current permutation and a list res for results.

Define recursive recurse():

If len(perm) == len(nums), append a copy to res.

Otherwise, for each number in counts:

If counts[num] > 0, append num, decrement count, recurse, then backtrack.

Call recurse() starting with empty perm.

Return res.

**Implement**
```py
class Solution(object):
    def permuteUnique(self, nums):
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        """
        if not nums:
            return [[]]
        res = []
        perm = []
        counts = Counter(nums)
        def recurse():
            if len(perm) == len(nums):
                res.append(perm[:])
            for num in counts:
                if counts[num] > 0:
                    perm.append(num)
                    counts[num] -= 1
                    recurse()
                    perm.pop()
                    counts[num] += 1
        recurse()
        return res
```

**Review**

Each permutation is built step by step, no duplicates because numbers with the same value are distinguished only by counts.

The algorithm explores exactly the necessary branches.

Efficient compared to generating all permutations and filtering.

**Evaluate**

Time Complexity: O(n! / (n1!·n2!·…)), i.e. number of unique permutations.

Space Complexity: O(n) recursion stack + O(n) for perm.

**Pattern to remember**
For generating unique permutations with duplicates: use a frequency map to track available numbers, recurse only on positive counts, backtrack, and stop when permutation length == n.