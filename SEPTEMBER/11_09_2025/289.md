## Game of Life
**Understand**

We are given a 2D board representing Conway’s Game of Life. Each cell is either alive (1) or dead (0). The next state is determined by these rules:

Any live cell with fewer than two live neighbors dies (underpopulation).

Any live cell with two or three live neighbors lives on.

Any live cell with more than three live neighbors dies (overpopulation).

Any dead cell with exactly three live neighbors becomes alive (reproduction).

We must update the board in-place, without using an additional copy of the board.

**Match**

This is an in-place grid update problem.

To avoid interfering with neighbor checks, use encoded transitional states:

0 → 0: dead stays dead.

1 → 0: live becomes dead (mark as 1).

0 → 1: dead becomes live (mark as 2).

1 → 1: live stays live (mark as 3).

First pass: encode transitions based on current state.

Second pass: decode back into 0 and 1.

**Plan**

Define neigh(r, c) to count live neighbors. Treat values 1 and 3 as “alive in original state.”

Traverse each cell:

If alive (1):

Survives if neighbors in {2, 3} → mark as 3.

If dead (0):

Becomes alive if neighbors == 3 → mark as 2.

After first pass, traverse again:

If cell in {2, 3} → set to 1.

If cell == 1 → set to 0.

**Implement**
```py
class Solution:
    def gameOfLife(self, board: List[List[int]]) -> None:
        """
        Do not return anything, modify board in-place instead.
        """
        # ORIGINAL | NEW | STATE
        #    0        0      0
        #    0        1      2
        #    1        0      1
        #    1        1      3

        neighbours = [(1,0), (0,1), (-1,0), (0,-1),
                      (1,1), (-1,-1), (1,-1), (-1,1)]
        rows, cols = len(board), len(board[0])

        def neigh(r, c):
            res = 0
            for dr, dc in neighbours:
                nr, nc = r + dr, c + dc
                if nr < 0 or nr == rows or nc < 0 or nc == cols:
                    continue
                if board[nr][nc] in (1, 3):
                    res += 1
            return res

        # First pass: encode transitions
        for r in range(rows):
            for c in range(cols):
                neighbour_count = neigh(r, c)
                if board[r][c] == 1:
                    if neighbour_count in (2, 3):
                        board[r][c] = 3
                else:
                    if neighbour_count == 3:
                        board[r][c] = 2

        # Second pass: finalize states
        for r in range(rows):
            for c in range(cols):
                if board[r][c] in (2, 3):
                    board[r][c] = 1
                elif board[r][c] == 1:
                    board[r][c] = 0
```

**Review**

Encoded states ensure neighbor counting is based on original board.

Two-pass solution achieves in-place update without extra memory.

Correctly applies Conway’s rules.

**Evaluate**

Time Complexity: O(R * C), scanning every cell twice.

Space Complexity: O(1), in-place with constant extra space.

**Pattern to remember**

For in-place grid updates with dependency on original state:

Encode transitional states (original + new).

First pass → encode transitions.

Second pass → decode to final values.