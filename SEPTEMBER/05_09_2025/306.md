## Additive Number
**Understand**
An additive number is a string whose digits can form a sequence of numbers where each number is the sum of the previous two, with at least three numbers in total. Leading zeros are not allowed unless the number itself is zero. Return True if num is additive.

Key rules:

Choose the first two numbers; the rest must be uniquely determined.

No leading zeros for multi-digit numbers.

**Match**
Brute-force the first two cuts, then recursively check the remainder: after picking (a, b), the next number must be str(a+b) and the remaining string must start with it; continue with (b, a+b).

**Plan**

Iterate over all splits num[:i] and num[i:j] for the first two numbers.

Skip any with leading zeros (unless the number is "0").

Define check(a, b, remaining):

If remaining is empty â†’ success.

Compute s = str(a+b); if remaining starts with s, recurse on (b, int(s), remaining[len(s):]); else fail.

Return True on the first valid sequence; otherwise False.

**Implement**
```py
class Solution(object):
    def isAdditiveNumber(self, num):
        """
        :type num: str
        :rtype: bool
        """
        n = len(num)
        def check(a, b, remaining):
            if not remaining:
                return True
            s = str(a+b)
            if not remaining.startswith(s):
                return False
            return check(b, int(s), remaining[len(s):])
        for i in range(1, n):
            for j in range(i+1, n):
                first, second = num[:i], num[i:j]
                print(first, second)
                if (len(first) > 1 and first[0] == '0') or (len(second) > 1 and second[0] == '0'):
                    continue
                if check(int(first), int(second), num[j:]):
                    return True
        return False
```

**Review**

Tries all O(n^2) first/second pairs; recursion validates the remainder deterministically.

Leading-zero pruning prevents invalid seeds.

Note: The print(first, second) line outputs debug info during execution.

**Evaluate**

Time Complexity: Up to O(n^2 * L) where L is the number of concatenations/comparisons during recursive checks.

Space Complexity: O(d) recursion depth (length of additive sequence).