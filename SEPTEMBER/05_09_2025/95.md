## Unique Binary Search Trees II

**Understand**
We’re asked to generate all structurally unique BSTs that store values 1..n.

Each BST must follow the BST property: left < root < right.

Different structures count as different BSTs, even if they contain the same values.

**Match**
Recursive tree construction:

Pick each number val in [left..right] as root.

Recursively generate all possible left subtrees from [left..val-1].

Recursively generate all possible right subtrees from [val+1..right].

Combine each left and right subtree with the root.

Base cases:

If left > right: return [None].

If left == right: return [TreeNode(left)].

**Plan**

Define helper generate(left, right) → returns list of all BST roots for numbers in [left..right].

If left > right: return [None] (empty tree).

If left == right: return [TreeNode(left)].

Otherwise:

Loop val from left to right.

Generate leftSubTree list from generate(left, val-1).

Generate rightSubTree list from generate(val+1, right).

For every pair (L, R), create TreeNode(val, L, R) and add to result.

Return the result list.

Call generate(1, n) as entry.