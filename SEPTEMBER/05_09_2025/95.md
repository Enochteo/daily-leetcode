## Unique Binary Search Trees II

**Understand**
We’re asked to generate all structurally unique BSTs that store values 1..n.

Each BST must follow the BST property: left < root < right.

Different structures count as different BSTs, even if they contain the same values.

**Match**
Recursive tree construction:

Pick each number val in [left..right] as root.

Recursively generate all possible left subtrees from [left..val-1].

Recursively generate all possible right subtrees from [val+1..right].

Combine each left and right subtree with the root.

Base cases:

If left > right: return [None].

If left == right: return [TreeNode(left)].

**Plan**

Define helper generate(left, right) → returns list of all BST roots for numbers in [left..right].

If left > right: return [None] (empty tree).

If left == right: return [TreeNode(left)].

Otherwise:

Loop val from left to right.

Generate leftSubTree list from generate(left, val-1).

Generate rightSubTree list from generate(val+1, right).

For every pair (L, R), create TreeNode(val, L, R) and add to result.

Return the result list.

Call generate(1, n) as entry.

**Implement**
```py
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def generateTrees(self, n):
        """
        :type n: int
        :rtype: List[Optional[TreeNode]]
        """
        def generate(left, right):
            if left == right:
                return [TreeNode(left)]
            if left > right:
                return [None]
            res = []
            for val in range(left, right + 1):
                for leftSubTree in generate(left, val - 1):
                    for rightSubTree in generate(val + 1, right):
                        root = TreeNode(val, leftSubTree, rightSubTree)
                        res.append(root)
            return res
        return generate(1, n)
```