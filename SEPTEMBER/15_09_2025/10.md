## Regular Expression Matching
**Understand**

We need to implement regex matching with support for:

. → matches any single character.

* → matches zero or more of the preceding element.

The entire string s must be matched by pattern p.

**Match**

This is a dynamic programming (DP) problem with recursion + memoization.

Direct recursion explores all matches.

* introduces branching: skip the x* (zero occurrences) or consume one character (if match).

Memoization (lru_cache) ensures subproblems are not recomputed.

**Plan**

Define recurse(i, j) = does s[i:] match p[j:].

Base case: if j == len(p), return i == len(s).

Check current character match:

True if i < len(s) and (s[i] == p[j] or p[j] == '.').

If next pattern char is *:

Option 1: skip p[j:j+2] → recurse(i, j+2).

Option 2: if match, consume one char → recurse(i+1, j).

Return OR of both.

Otherwise (no *):

Return match and recurse(i+1, j+1).

Start recursion with (0, 0).