## Regular Expression Matching
**Understand**

We need to implement regex matching with support for:

. → matches any single character.

* → matches zero or more of the preceding element.

The entire string s must be matched by pattern p.

**Match**

This is a dynamic programming (DP) problem with recursion + memoization.

Direct recursion explores all matches.

* introduces branching: skip the x* (zero occurrences) or consume one character (if match).

Memoization (lru_cache) ensures subproblems are not recomputed.

**Plan**

Define recurse(i, j) = does s[i:] match p[j:].

Base case: if j == len(p), return i == len(s).

Check current character match:

True if i < len(s) and (s[i] == p[j] or p[j] == '.').

If next pattern char is *:

Option 1: skip p[j:j+2] → recurse(i, j+2).

Option 2: if match, consume one char → recurse(i+1, j).

Return OR of both.

Otherwise (no *):

Return match and recurse(i+1, j+1).

Start recursion with (0, 0).

**Implement**
```py
from functools import lru_cache

class Solution:
    def isMatch(self, s: str, p: str) -> bool:
        @lru_cache()
        def recurse(index1, index2):
            if index2 == len(p):
                return index1 == len(s)
            
            match = index1 < len(s) and (s[index1] == p[index2] or p[index2] == '.')
            
            if index2 + 1 < len(p) and p[index2 + 1] == '*':
                return recurse(index1, index2 + 2) or (match and recurse(index1 + 1, index2))
            else:
                return match and recurse(index1 + 1, index2 + 1)
        
        return recurse(0, 0)
```

**Review**

Correctly handles . as wildcard.

Correctly branches on * for both zero and multiple occurrences.

Uses memoization to optimize repeated subproblems.

**Evaluate**

Time Complexity: O(len(s) * len(p)), since each (i, j) pair is solved once.

Space Complexity: O(len(s) * len(p)) recursion depth + memo cache.

**Pattern to remember**

For regex matching with . and *:

Recursive DP with (i, j) state = does s[i:] match p[j:].

* → branch into skip (j+2) or consume one (i+1).

Memoize results to avoid recomputation.