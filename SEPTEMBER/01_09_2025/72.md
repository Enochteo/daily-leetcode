## Edit Distance
**Understand**
Given two strings `word1` and `word2` return the minimum number of oprations required to convert `word1` to `word2`.
You can perform these operations:
- Insert a character
- Delete a character
- Replace a character

**Example**
Input: `word1` = `horse`, `word2` = `ros`
Output: 3
Explanation: 
horse -> rorse (replace 'h' with 'r')
rorse -> rose (remove 'r')
rose -> ros (remove 'e')

**Match**
The question is an optimization problem to find the minimum number of changes out of many to change a word to the other word. The optimized solution would be dynamic programming but this solution would make use of recursive backtracking a brute force approach to finding theminimum number of operations to be made to turn word1 into word2.

**Plan**
We would tract the states as the indexes of both words we are currently at starting from 0 till the end, and the transition would be the operations (insert at the index, replace, or delete) or leave alone if the string is the same at that index.
Base Cases:
- When the index is at the end of string 1 -> return the number of characters left (to be deleted)
- When the index is at the end of string 2 -> return the number of characters left (to be deleted)
- when the string at both indexex are equal -> recurse and return the min ways for the subproblems without adding 1 (index1 + 1, index2 + 1)
- else case find the minimum ways from each operations.

**Implement**
```py
class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        @lru_cache()
        def recurse(index1, index2):
            if index1 == len(word1):
                return len(word2) - index2
            if index2 == len(word2):
                return len(word1) - index1
            if word1[index1] == word2[index2]:
                return recurse(index1 + 1, index2 + 1)
            else:
                return 1 + min(recurse(index1 + 1, index2), recurse(index1, index2 + 1), recurse(index1 + 1, index2 + 1))
        return recurse(0, 0)
```