## Cheapest Flights Within K Stops
**Understand**

We are given n cities labeled 0..n-1, a list of flights flights[i] = [from, to, price], a source city src, a destination city dst, and an integer k.

We need to return the cheapest price from src to dst with at most k stops. If no route exists, return -1.

**Match**

This is a shortest path problem with a stop constraint.

Standard Dijkstra finds shortest path, but here we also need to track the number of stops.

Use a priority queue (cost, node, stops) to always expand the cheapest path first.

Use a DP table dist[node][stops] to record the cheapest cost to reach node with stops stops.

**Plan**

Build adjacency list: adj[from] = [(to, cost), â€¦].

Initialize dist[n][k+2] with inf, since we may visit up to k+1 edges.

Push (0, src, 0) into min-heap. Set dist[src][0] = 0.

While heap not empty:

Pop (cur_cost, cur_node, stops).

If cur_node == dst: return cur_cost.

If stops <= k:

For each (nei, cost) in adjacency list:

Compute new_cost = cur_cost + cost.

If new_cost < dist[nei][stops+1], update and push (new_cost, nei, stops+1) into heap.

If heap exhausts without reaching dst, return -1.

**Implement**
```py

import heapq
from collections import defaultdict

class Solution(object):
    def findCheapestPrice(self, n, flights, src, dst, k):
        """
        :type n: int
        :type flights: List[List[int]]
        :type src: int
        :type dst: int
        :type k: int
        :rtype: int 
        """
        adj = defaultdict(list)
        for s, d, c in flights:
            adj[s].append((d, c))
        
        dist = [[float('inf')] * (k+2) for _ in range(n)]
        q = [(0, src, 0)]
        dist[src][0] = 0

        while q:
            cur_cost, cur, stops = heapq.heappop(q)
            if cur == dst:
                return cur_cost
            if stops <= k:
                for nei, cost in adj[cur]:
                    new_cost = cost + cur_cost
                    if new_cost < dist[nei][stops + 1]:
                        heapq.heappush(q, (new_cost, nei, stops + 1))
                        dist[nei][stops + 1] = new_cost
        return -1
```