## Course Schedule
**Understand**

We are given numCourses and a list of prerequisite pairs [a, b] meaning you must complete course b before course a.

We need to determine if it’s possible to finish all courses (i.e., no circular dependencies).

**Match**

This is a cycle detection in a directed graph problem.

Graph = courses as nodes, prerequisites as directed edges.

If graph has a cycle → cannot finish.

Solution: DFS with recursion stack (track path).

**Plan**

Build adjacency list: adj[course] = [list of prerequisites].

Maintain two sets:

visit = courses fully processed (safe).

path = current recursion stack (detect cycles).

Define DFS:

If node in path → cycle → return False.

If node in visit → already processed → return True.

Add node to path.

Recurse on neighbors. If any returns False → fail.

Remove node from path, add to visit.

Return True.

For each course not in visit, run DFS.

If all pass, return True.

**Implement**
```py
from collections import defaultdict

class Solution(object):
    def canFinish(self, numCourses, prerequisites):
        """
        :type numCourses: int
        :type prerequisites: List[List[int]]
        :rtype: bool
        """
        adj = defaultdict(list)
        for course, prereq in prerequisites:
            adj[course].append(prereq)
        
        visit = set()
        path = set()
        
        def dfs(node):
            if node in path:
                return False
            if node in visit:
                return True
            path.add(node)
            for nei in adj[node]:
                if not dfs(nei):
                    return False
            path.remove(node)
            visit.add(node)
            return True

        for i in range(numCourses):
            if i not in visit:
                if not dfs(i):
                    return False
        return True
```

**Review**

Uses DFS to explore graph and detect cycles.

path tracks active recursion stack; hitting a node already in path indicates a cycle.

visit avoids reprocessing nodes.

**Evaluate**

Time Complexity: O(V + E), where V = courses, E = prerequisites.

Space Complexity: O(V + E) for adjacency list, visited sets, and recursion stack.

**Pattern to remember**

For course scheduling / cycle detection in directed graphs:

Use DFS with a recursion stack (path).

If a node is revisited while still in stack → cycle detected.

Otherwise, safe nodes are added to visit.