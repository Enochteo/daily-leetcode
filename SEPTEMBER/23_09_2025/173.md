## Binary Search Tree Iterator
**Understand**
We are asked to implement a binary tree iterator that iterates over a BST in sorted order (inorder) `left->cur->right`.
It should have three methods:
- `__init__` - to initialize the class
- `next` - to move the current pointer to the next element in the inorder sequence (next greater element) and then return the node. (N.B It would always have a next)
- `hasNext` - which returns a boolean as to whether or not there exists a node next to the current node in the iterator.


**Match**
- Binary Tree Traversal 
- For Sorted BST property (inorder) DFS would be needed more specifically iterative.

**Plan**
- Use a stack to get the leftmost nodes from the root including the root at initialization
- `next`: pop from the stack and add any right children of the popped node.
- `hasNext`: check if the current stack (class variable) if non-empty and return.

**Implement**
```py
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class BSTIterator:

    def __init__(self, root: Optional[TreeNode]):
        self.stack = []
        cur = root
        while cur:
            self.stack.append(cur)
            cur = cur.left

    def next(self) -> int:
        node = self.stack.pop()
        cur = node.right
        while cur:
            self.stack.append(cur)
            cur = cur.left
        return node.val

    def hasNext(self) -> bool:
        return len(self.stack) > 0


# Your BSTIterator object will be instantiated and called as such:
# obj = BSTIterator(root)
# param_1 = obj.next()
# param_2 = obj.hasNext()
```

**Review**
- `next` works correctly as expected in that it gets the next node in the current travesal and even works for the first node as we don't pop (traverse) until `next` is called.
- `hasNext` also works well even for trees with one node.

-  `next` has a return value of TreeNode and `hasNext` has a Boolean return value