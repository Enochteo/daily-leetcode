## Flatten Binary Tree Linked List
**Undeerstand**
Given the root of a binary tree, flatten the tree into a "linked list". This should be done in such a way that:
- all nodes should be connected only via the right pointers
- all nodes connection maintain the preorder traversal of the original tree
i.e

```
    1
   / \
  2   5
 / \    \
3   4    6
``` 
becomes...
```
    1
     \
      2
       \
        3
         \
          4
           \
            5
             \
              6
```

**Match**
This problem combines knoledge of binary trees specifically Preorder Traversal as well as imagery of how a linked list is or should be.

Each node would be converted from having two children to having one child as described in the problem. 
This problem would be solved in subproblems - recursively (Divide and Conquer)
**How**:
- For the root node, we flatten the left subtree and the right subtree
- we connect the left flattened list to be in-between the root node and the right flattened list 

**Plan**
- Define an helper function to flatten a tree

- Add the base case for null nodes

- Recursively get the left tail

- Recursively get the right tail

- if the left tail exists:
    - connect its right pointer to the right of the root
    - connect the roots right to the head of the flattened left list (root.left)
    - set the root's left to None

- Return the overall tail right tail  else the left tail else the right tail

