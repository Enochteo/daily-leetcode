## Unique Paths
**Understand**
We are given a grid of size m x n. A robot starts at the top-left (0,0) and can only move down or right. Find the total number of unique paths to reach the bottom-right (m-1,n-1).

**Match**
Recursive DFS with memoization:

From (row, col), the number of paths = paths from (row+1, col) (down) + (row, col+1) (right).

Base cases:

If at bottom-right cell → 1 path.

If out of bounds → 0 paths.

Use lru_cache to memoize states and avoid recomputation.

**Plan**

Define recurse(row, col) that returns paths from (row, col) to (m-1,n-1).

Base cases:

If (row, col) == (m-1,n-1) → return 1.

If row >= m or col >= n → return 0.

Recursive case: return recurse(row+1, col) + recurse(row, col+1).

Memoize with @lru_cache() to avoid exponential blowup.

Start with recurse(0,0).

**Implement**
```py
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        @lru_cache()
        def recurse(row, col):
            if row == m-1 and col == n-1:
                return 1
            if row >= m or col >= n:
                return 0
            return recurse(row + 1, col) + recurse(row, col + 1)
        return recurse(0, 0)
```