## Unique Paths - Optimized
**Understand**
We need the number of unique paths in an m x n grid from top-left (0,0) to bottom-right (m-1,n-1) moving only down or right.

**Match**
Dynamic Programming (tabulation):

Each cell (r,c) stores the number of paths from (r,c) to the goal.

Transition: dp[r][c] = dp[r+1][c] + dp[r][c+1].

Base case: dp[m-1][n-1] = 1.

Fill table from bottom-right corner back to (0,0).

**Plan**

Initialize DP table (m+1) x (n+1) with zeros (extra padding to avoid out-of-bounds).

Set base case: dp[m-1][n-1] = 1.

Traverse rows backward m-1 → 0 and cols backward n-1 → 0:

Update dp[r][c] += dp[r+1][c] + dp[r][c+1].

Answer is dp[0][0].

**Implement**
```py
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        dp = [[0] * (n+1) for _ in range(m+1)]
        dp[m-1][n-1] = 1
        for r in range(m-1, -1, -1):
            for c in range(n-1, -1, -1):
                dp[r][c] += dp[r+1][c] + dp[r][c+1]
        return dp[0][0]
```

**Review**

Padding ensures dp[r+1][c] and dp[r][c+1] are always valid without boundary checks.

Loops correctly fill bottom-up and right-to-left.

Produces same result as recursion+memo, but avoids recursion depth.

**Evaluate**

Time Complexity: O(m·n).

Space Complexity: O(m·n).

Can be optimized to O(n) using a 1D rolling array.