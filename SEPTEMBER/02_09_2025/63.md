## Unique Paths II

**Understand**
Given a grid obstacleGrid where 1 denotes an obstacle and 0 an empty cell, count the number of unique paths from top-left (0,0) to bottom-right (m-1,n-1) moving only down or right. If the start or end is blocked, the answer is 0.

**Match**
Two standard approaches, both in your code:

Bottom-up DP with an extra padded row/column to avoid bounds checks; accumulate paths from destination backwards, skipping obstacle cells.

Top-down DFS with memoization (lru_cache), returning 0 when out of bounds or on an obstacle, and 1 at the destination.

**Plan**

DP tabulation: initialize a (rows+1) x (cols+1) table with zeros, set base at bottom-right to 1 if not an obstacle, then fill from bottom-right to top-left: dp[r][c] = dp[r+1][c] + dp[r][c+1] for free cells.

DFS + memo: recursively sum paths from (r+1,c) and (r,c+1) with obstacle and boundary guards; cache results.

**Implement**
```py
# Bottom-up DP
class Solution:
    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:
        rows, cols = len(obstacleGrid), len(obstacleGrid[0])
        dp = [[0]*(cols + 1) for _ in range(rows + 1)] 
        for r in range(rows-1, -1, -1):
            for c in range(cols-1, -1, -1):
                if r == rows-1 and c == cols-1:
                    if obstacleGrid[r][c] == 1:
                        dp[r][c] = 0
                    else:
                        dp[r][c] = 1
                    continue
                if obstacleGrid[r][c] != 1:
                    dp[r][c] = dp[r+1][c] + dp[r][c+1]
        return dp[0][0]
```
```py
# Recursive backtracking with memoization
class Solution:
    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:
        rows, cols = len(obstacleGrid), len(obstacleGrid[0])
        @lru_cache
        def recurse(r, c):
            if r >= rows or c >= cols or obstacleGrid[r][c] == 1:
                return 0
            if r == rows-1 and c == cols-1:
                return 1
            return recurse(r + 1, c) + recurse(r, c + 1)
        return recurse(0, 0)
```

**Review**

DP version: Uses padding so dp[r+1][c] / dp[r][c+1] are always defined; base cell (rows-1, cols-1) set to 1 if free, else 0. Obstacle cells remain 0.

DFS + memo: Clean boundary/obstacle guard; base case returns 1 only at destination. Memoization ensures each state computed once.

**Evaluate**

Time Complexity: Both O(m·n) states.

Space Complexity: DP uses O(m·n) table; DFS uses O(m·n) cache and up to O(m+n) recursion depth.

Both correctly yield 0 when start or end is blocked.

**Pattern to remember**
For grid path counting with obstacles:

DP formula: if free, ways[r][c] = ways[r+1][c] + ways[r][c+1]; if obstacle, 0.

You can implement either bottom-up tabulation with padding or top-down recursion with memoization; both compute the same recurrence efficiently.