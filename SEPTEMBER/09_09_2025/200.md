## Number of Islands
Understand

We are given a 2D grid of '1's (land) and '0's (water). An island is a group of connected '1's connected vertically or horizontally (not diagonally).

The task is to return the number of distinct islands.

**Example**:
```
Input: 
grid = [
  ["1","1","0","0"],
  ["1","0","0","1"],
  ["0","0","1","1"]
]
Output: 3
```

**Match**

This is a graph traversal problem.

Model the grid as a graph where each land cell is a node.

Perform DFS/BFS from each unvisited land cell to mark the entire island.

Count how many DFS/BFS calls are needed.

**Plan**

Initialize islands = 0 and visited set.

Define dfs(r, c):

Base case: return if out of bounds, water, or already visited.

Otherwise, mark (r, c) visited.

Recurse in four directions.

Iterate over all cells (r, c) in the grid:

If the cell is '1' and not visited, increment islands and call dfs(r, c).

Return islands.

**Implement**
```py
class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        rows = len(grid)
        cols = len(grid[0])
        islands = 0
        visited = set()
        directions = [(1, 0), (0, 1), (-1, 0), (0, -1)]
        
        def dfs(r, c):
            if (r < 0 or c < 0 or 
                r >= rows or c >= cols or 
                (r, c) in visited or 
                grid[r][c] == '0'):
                return
            visited.add((r, c))
            for dr, dc in directions:
                dfs(r + dr, c + dc)
        
        for r in range(rows):
            for c in range(cols):
                if grid[r][c] == '1' and (r, c) not in visited:
                    islands += 1
                    dfs(r, c)
        return islands
```