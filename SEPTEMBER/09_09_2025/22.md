## Generate Parentheses
**Understand**

We need to generate all valid combinations of n pairs of parentheses.

Example:

n = 3 → ["((()))","(()())","(())()","()(())","()()()"].

Constraints:

1 <= n <= 8.

**Match**

This is a backtracking problem:

Keep track of how many ( and ) have been used.

Only add ( if we haven’t used all n.

Only add ) if it won’t make the string invalid (i.e., if opens > closes).

**Plan**

Initialize res as the answer list.

Define recursive function generate(path, opens, closes):

If len(path) == 2*n, append to result.

If opens < n, add ( and recurse.

If closes < n and opens > closes, add ) and recurse.

Start recursion with path="(", opens=1, closes=0.

Return res.

**Implement**
```py
class Solution(object):
    def generateParenthesis(self, n):
        """
        :type n: int
        :rtype: List[str]
        """
        res = []
        def generate(path, opens, closes):
            if len(path) == n * 2:
                res.append(path)
                return
            if opens < n:
                generate(path + '(', opens + 1, closes)
            if closes < n and opens > closes:
                generate(path + ')', opens, closes + 1)
        generate('(', 1, 0)
        return res
```

**Review**

Ensures only valid parentheses strings are generated.

Prevents invalid cases by enforcing opens >= closes throughout recursion.

Correctly stops at length 2*n.