## Jump Game
**Understand**
Given an array nums, where each nums[i] is the max jump length from index i, return True if you can reach the last index starting at 0, else False.

Example:

[2,3,1,1,4] → True (0→1→4).

[3,2,1,0,4] → False (stuck at index 3).


**Match**
Greedy approach: as you traverse, maintain the farthest index you can reach. If at any point the current index is beyond that farthest, you cannot continue → return False. Otherwise, update the farthest. At the end, check if the farthest ≥ last index.

**Plan**

Initialize farthest = 0.

For each index i from 0 to n−1:

If i > farthest, return False (stuck).

Update farthest = max(farthest, i + nums[i]).

After loop, if farthest ≥ n−1, return True, else False.

**Implement**
```py
class Solution:
    def canJump(self, nums: List[int]) -> bool:
        farthest = 0
        for i in range(len(nums)):
            if i > farthest:
                return False
            farthest = max(farthest, i + nums[i])
        if farthest >= len(nums)-1:
            return True
```

**Review**

Greedy strategy ensures O(n) time.

Handles edge cases:

Single element array → trivially True.

Zeros in the middle → handled by the stuck check.

The if farthest >= len(nums)-1: return can also be placed inside the loop for early exit.