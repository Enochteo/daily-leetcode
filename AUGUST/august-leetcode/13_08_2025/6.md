## Zigzag Conversion
**Understand**
Given a string s and an integer numRows, write the characters in a zigzag pattern on numRows of rows and then read row-by-row to produce a new string.

If numRows == 1 or numRows >= len(s), the output is s.

For general numRows, characters repeat in cycles of length cycle = 2*(numRows-1).

Middle rows pick up two characters per cycle: one on the vertical, one on the diagonal.

**Match**
String indexing with arithmetic using the cycle length.
Alternative pattern: simulate row-by-row with directional traversal, but direct indexing is simpler and O(1) extra per char.

**Plan**

If numRows == 1 or numRows >= len(s), return s.

Compute cycle = 2*(numRows-1).

For each row r from 0 to numRows-1:

Append characters at indices i = r, r+cycle, r+2*cycle, ....

If 0 < r < numRows-1, also append the diagonal index j = i + (cycle - 2*r) when j < len(s).

Concatenate the collected characters and return.

**Implement**
```py
class Solution(object):
    def convert(self, s, numRows):
        """
        :type s: str
        :type numRows: int
        :rtype: str
        """
        n = len(s)
        if numRows == 1 or numRows >= n:
            return s

        cycle = 2 * (numRows - 1)
        out = []

        for r in range(numRows):
            i = r
            while i < n:
                out.append(s[i])  # vertical hit
                # diagonal hit for middle rows
                if 0 < r < numRows - 1:
                    j = i + (cycle - 2 * r)
                    if j < n:
                        out.append(s[j])
                i += cycle

        return "".join(out)
```
**Review**

Example: s="PAYPALISHIRING", numRows=3

cycle = 4; rows:

r=0: indices 0,4,8,12 → P A H N

r=1: vertical 1,5,9,13 and diagonal 3,7,11 → A P L S I I G

r=2: indices 2,6,10 → Y I R
Output: "PAHNAPLSIIGYIR".

Matches the expected zigzag reading

**Evaluate**
Time Complexity: O(n), each character appended at most once.
Space Complexity: O(n) for the output (O(1) auxiliary beyond that).
Alternatives:

Simulation with rows = [''] * numRows and a direction flip; equally O(n), often easier to reason about but similar complexity.

Direct indexing (as above) avoids maintaining direction state and is concise.