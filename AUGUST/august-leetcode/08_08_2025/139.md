## Word Break
**Understand**
Given a string s and a dictionary of words wordDict, determine if s can be segmented into a space-separated sequence of one or more dictionary words.

All the words in the dictionary are non-empty and contain only lowercase letters.

We can reuse words from the dictionary multiple times.

**Match**
This is a classic Dynamic Programming + DFS problem.

You can use a Trie to optimize prefix matching.

Combine this with memoization to avoid redundant DFS calls.

**Plan**
Insert all words in wordDict into a Trie.

Define a recursive DFS that tries to segment s from a given index.

At each step, traverse through the Trie and check if any prefix forms a valid word.

If it does, recursively check the remainder of the string.

Use memoization to store and reuse the result of subproblems.

**Implement**
```python
class TrieNode():
    def __init__(self):
        self.children = {}
        self.endOfWord = False

class Trie():
    def __init__(self):
        self.root = TrieNode()

    def insert(self, word):
        node = self.root
        for char in word:
            if char not in node.children:
                node.children[char] = TrieNode()
            node = node.children[char]
        node.endOfWord = True
    

class Solution(object):
    def wordBreak(self, s, wordDict):
        """
        :type s: str
        :type wordDict: List[str]
        :rtype: bool
        """
        new_trie = Trie()
        for word in wordDict:
            new_trie.insert(word)

        memo = {}
        def dfs(index):
            if index == len(s):
                return True
            if index in memo:
                return memo[index]
            node = new_trie.root
            for i in range(index, len(s)):
                char = s[i]
                if char not in node.children:
                    break
                node = node.children[char]
                if node.endOfWord:
                    if dfs(i + 1):
                        memo[index] = True
                        return True
            memo[index] = False
            return False

        return dfs(0)
```
**Review**
Trie reduces the cost of word prefix matching.

DFS is made efficient with memoization (avoids recomputing overlapping subproblems).

**Evaluate**
Time Complexity:

Let n = len(s) and m be the max length of a word in the dictionary.

In the worst case, the algorithm tries every possible segmentation, but memoization reduces repeated work.

Insertion into Trie: O(total characters in wordDict)

DFS with memoization: O(n * m)

Space Complexity:

O(n) for memoization

O(total characters in wordDict) for the Trie

O(n) call stack in worst case due to recursion

**Pattern to Remember**
Word Segmentation + Trie + DFS + Memoization: Use a Trie to reduce prefix lookup time, DFS to explore all valid segmentations, and memoization to avoid recomputation.