## Jump Game II - Solution version 2
**Understand**
Given an array nums, where each nums[i] is the maximum jump length from index i, return the minimum number of jumps required to reach the last index. It is guaranteed that you can always reach the end.

**Match**
Greedy scan.

Maintain farthest = max index reachable so far.

Maintain current_end = farthest index reachable with the current number of jumps.

When reaching current_end, increment jump count and update current_end = farthest.
This ensures each time we extend our range with minimal jumps (like BFS levels but optimized to O(n)).

**Plan**

Handle base case: if nums has only one element, return 0.

Initialize jumps = 0, current_end = 0, farthest = 0.

Loop through indices i from 0 to len(nums)-2 (no need to process the last index):

Update farthest = max(farthest, i + nums[i]).

If i == current_end:

Increment jumps.

Update current_end = farthest.

If current_end >= len(nums)-1, break.

Return jumps.

**Implement**
```py
class Solution:
    def jump(self, nums: List[int]) -> int:
        if len(nums) == 1:
            return 0
        jumps = 0
        current_end = 0
        farthest = 0
        for i in range(len(nums)-1):
            farthest = max(farthest, i + nums[i])
            if i == current_end:
                jumps += 1
                current_end = farthest
                if current_end >= len(nums)-1:
                    break
        return jumps
```

**Review**

Greedy ensures optimal jumps because we always take the largest possible extension at each level.

Loop runs to len(nums)-2 since reaching the last index doesnâ€™t require exploring beyond.

The if current_end >= len(nums)-1 condition allows early stopping.