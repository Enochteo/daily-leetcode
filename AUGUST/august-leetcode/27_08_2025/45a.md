## Jump Game II - Solution version 2
**Understand**
Given an array nums, where each nums[i] is the maximum jump length from index i, return the minimum number of jumps required to reach the last index. It is guaranteed that you can always reach the end.

**Match**
Greedy scan.

Maintain farthest = max index reachable so far.

Maintain current_end = farthest index reachable with the current number of jumps.

When reaching current_end, increment jump count and update current_end = farthest.
This ensures each time we extend our range with minimal jumps (like BFS levels but optimized to O(n)).

**Plan**

Handle base case: if nums has only one element, return 0.

Initialize jumps = 0, current_end = 0, farthest = 0.

Loop through indices i from 0 to len(nums)-2 (no need to process the last index):

Update farthest = max(farthest, i + nums[i]).

If i == current_end:

Increment jumps.

Update current_end = farthest.

If current_end >= len(nums)-1, break.

Return jumps.