## Gas Station
**Understand**
We are given two arrays gas and cost, each of length n.

gas[i] = amount of gas at station i.

cost[i] = gas needed to travel from station i to (i+1) % n.

Find the starting station index from which you can travel around the circuit once, or return -1 if impossible.

Observation:

If sum(gas) < sum(cost), total gas is insufficient → return -1.

If a solution exists, it is unique.

Match
Greedy approach:

Keep a running tank of gas while iterating.

If tank drops below 0 at station i, then no station from the current start up to i can be a valid start → reset start to i+1.

**Plan**

If total gas < total cost, return -1.

Initialize tank = 0, start = 0.

For each station i:

Update tank += gas[i] - cost[i].

If tank < 0, reset start = i+1 and tank = 0.

Return start.

**Implement**
```py
class Solution:
    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:
        if sum(gas) < sum(cost):
            return -1
        tank = 0
        start = 0
        for i in range(len(gas)):
            tank += gas[i] - cost[i]
            if tank < 0:
                start = i + 1
                tank = 0
        return start
```

**Review**

Global feasibility check ensures only one pass is needed.

Resetting start works because if the tank is negative at i, no earlier station could have carried us to i+1.

**Evaluate**

Time Complexity: O(n)

Space Complexity: O(1)

**Pattern to remember**
For circular problems with deficits: if cumulative sum goes negative, reset start to next index and reset tank, because no index in the failed segment can be a valid starting point.