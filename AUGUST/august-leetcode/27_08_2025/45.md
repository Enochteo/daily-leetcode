## Jump Game II
**Understand**
You are given an array nums, where nums[i] is the maximum jump length from index i. Starting at index 0, return the minimum number of jumps needed to reach the last index. You can always reach the end.

**Example**:

nums = [2,3,1,1,4] → 2 (0→1→4).

nums = [2,3,0,1,4] → 2.

**Match**
Greedy / BFS-level idea. Think of the array as layers of reachable indices:

At each jump, expand the current range [l, r] (the indices reachable with current jumps).

Find the farthest index reachable from this range.

Update range to [r+1, farthest] and increment jumps.

Continue until r ≥ n-1.

**Plan**

Initialize jumps = 0, l = r = 0.

While the current range does not reach the end (r < n-1):

Compute farthest = max(i + nums[i]) for all i in [l..r].

Update window: l = r+1, r = farthest.

Increment jumps.

Return jumps.

**Implement**
```py
class Solution:
    def jump(self, nums: List[int]) -> int:
        jumps = 0
        n = len(nums) - 1
        l = r = 0
        while r < n:
            farthest = 0
            for i in range(l, r + 1):
                farthest = max(farthest, i + nums[i])
            l = r + 1
            r = farthest
            jumps += 1
        return jumps
```

**Review**

Correctly counts layers of reachability (like BFS in an unweighted graph).

Ensures minimal jumps by expanding breadth-first.

Works because every index is guaranteed to eventually reach the end.

**Evaluate**

Time Complexity: O(n²) worst case (nested loop across each range).

Optimizable to O(n): Instead of looping i through [l..r] explicitly each time, maintain running farthest as you scan.

**Pattern to remember**
For minimum jumps in a jump array: treat the problem as BFS levels — track the current range [l, r] (reachable with current jumps), compute the next farthest reach, update range, and increment jump count until the end is within reach.