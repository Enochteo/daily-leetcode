## Merge Intervals
**Understand**
Given an array of intervals [[s1,e1], [s2,e2], ...], merge all overlapping intervals and return a list of non-overlapping intervals that covers the same ranges.

Overlap occurs when the next start s is <= the current merged end.

Intervals may be in any order.

**Match**
Sorting + linear sweep. After sorting by start, maintain a current merged interval and extend it while overlaps continue.

**Plan**

If intervals is empty, return [].

Sort intervals by start time (key=lambda x: x[0]).

Initialize merged = [] and set cur_start, cur_end from the first interval.

For each subsequent [s, e]:

If s <= cur_end, merge: cur_end = max(cur_end, e).

Else, append [cur_start, cur_end] to merged, then reset cur_start, cur_end = s, e.

Append the last [cur_start, cur_end] and return merged.