## Merge Intervals
**Understand**
Given an array of intervals [[s1,e1], [s2,e2], ...], merge all overlapping intervals and return a list of non-overlapping intervals that covers the same ranges.

Overlap occurs when the next start s is <= the current merged end.

Intervals may be in any order.

**Match**
Sorting + linear sweep. After sorting by start, maintain a current merged interval and extend it while overlaps continue.

**Plan**

If intervals is empty, return [].

Sort intervals by start time (key=lambda x: x[0]).

Initialize merged = [] and set cur_start, cur_end from the first interval.

For each subsequent [s, e]:

If s <= cur_end, merge: cur_end = max(cur_end, e).

Else, append [cur_start, cur_end] to merged, then reset cur_start, cur_end = s, e.

Append the last [cur_start, cur_end] and return merged.

**Implement**
```py
class Solution(object):
    def merge(self, intervals):
        """
        :type intervals: List[List[int]]
        :rtype: List[List[int]]
        """
        intervals.sort()
        res = [] 
        i = 0
        while i < len(intervals):
            start_time, end_time = intervals[i][0], intervals[i][1]
            j = i
            while j < len(intervals) and intervals[j][0] <= end_time:
                j += 1
                if intervals[j-1][1] > end_time:
                    end_time = intervals[j-1][1]
            i = j
            res.append([start_time, end_time])

        return res
```
**Review**

Sorting by start ensures all potential overlaps appear contiguously.

The sweep keeps only one active interval; when a gap is found, we finalize and start a new one.

Handles nested intervals (e.g., [1,10] with [2,3]) via max(cur_end, e).

**Evaluate**
Time Complexity: O(n log n) for sorting, O(n) for the sweep.
Space Complexity: O(1) auxiliary (output list aside).
Alternative: Line sweep with event counts (start +1, end −1) is overkill here and more complex to reconstruct merged ranges.

**Pattern to remember**
For interval merging: sort by start, then accumulate a current range; for each next interval, extend if overlapping (start ≤ current_end), otherwise flush current and start a new one.