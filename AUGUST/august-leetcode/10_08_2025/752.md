## Open the Lock
**Understand**
You have a lock with 4 wheels, each showing a digit 0–9. From any state, a move consists of turning one wheel up or down by one (wrapping around).
Given a list of deadend states you cannot enter and a target state, return the minimum number of moves to reach the target from "0000". If impossible, return -1.

**Match**
Shortest path in an unweighted graph of states → Breadth-First Search (BFS)

State space: all 4-digit strings 0000–9999

Generate neighbors by rotating each wheel up/down

**Plan**
If "0000" is a deadend, return -1.

Use BFS from "0000", tracking (state, distance) in a queue.

For each state, generate up to 8 neighbors by incrementing/decrementing each wheel.

Skip states already visited or in deadends.

When the target is dequeued, return its distance (turn count).

If BFS exhausts without reaching target, return -1.

**Implement**
```python
class Solution(object):
    def openLock(self, deadends, target):
        """
        :type deadends: List[str]
        :type target: str
        :rtype: int
        """
        if "0000" in deadends:
            return -1
        def children(lock):
            res = []
            for i in range(4):
                digit = str((int(lock[i]) + 1) % 10)
                res.append(lock[:i] + digit + lock[i+1:])
                digit = str((int(lock[i]) - 1 + 10) % 10)
                res.append(lock[:i] + digit + lock[i+1:])
            return res
    
        q = deque() 
        q.append(["0000", 0])#lock, turns
        visited = set(deadends)
        while q:
            lock, turns = q.popleft()
            if lock == target:
                return turns
            for child in children(lock):
                if child not in visited:
                    visited.add(child)
                    q.append([child, turns + 1])
        return -1
```

**Review**
- BFS guarantees minimum moves in an unweighted graph.

- Neighbor generation is O(1) per wheel and uses modular arithmetic to wrap digits.

- Early checks for starting deadend and trivial target

- Instead of generating all the children and returning it as a list, one could use python's `yield` keyword that causes a generator that yields all values (4 values in this case) for the for loop

**Evaluate**
Time Complexity: O(V + E) where V ≤ 10^4 states and each state has up to 8 edges → effectively O(10^4).
Space Complexity: O(10^4) for the visited set and queue.