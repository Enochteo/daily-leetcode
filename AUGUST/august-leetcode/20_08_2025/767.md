## Reorganize String
**Understand**
Given a string s, rearrange its letters so that no two adjacent characters are the same. If it’s impossible, return "".

Key constraint: if any character’s count exceeds (len(s)+1)//2, rearrangement is impossible.

**Match**
Greedy with a max-heap (by frequency). Always place the currently most frequent available character, while keeping the previously used character “on hold” until the next step so it doesn’t repeat.

**Plan**
Count frequencies; early-impossible check with maxCount > (n+1)//2.

Build a max-heap via negative counts.

Keep a prev tuple for the character used in the last step with its remaining count.

Each iteration:

Pop the top (cnt, ch), append ch to result.

If prev still has remaining count, push it back.

Decrement current count and set it as new prev.

When heap is empty, return the built string.

**Implement**
```py
class Solution(object):
    def reorganizeString(self, s):
        """
        :type s: str
        :rtype: str
        """
        res = ""
        counts = Counter(s)
        maxCount = max(counts.values())
        if maxCount > (len(s) + 1) // 2:
            return ""
        freq = [(-count, char) for char, count in counts.items()]
        heapq.heapify(freq)
        prev = (0, "")
        while freq:
            cnt, c = heapq.heappop(freq)
            res += str(c)
            if prev[0] < 0:
                heappush(freq, prev)
            cnt += 1
            prev = (cnt, c)
        return res
```
**Review**
Early feasibility check prevents wasted work when a letter is too frequent.

The prev mechanism ensures no adjacent duplicates by delaying re-use until at least one different char is placed.

Note: this snippet calls heappush without the heapq. prefix; ensure from heapq import heappush is present, or change the call site to heapq.heappush in your environment.

**Evaluate**
Time Complexity: O(n log k), where n = len(s) and k is the number of distinct characters (each push/pop is log k).
Space Complexity: O(k) for the heap and counts.

**Pattern to remember**
When you must arrange items to avoid placing identical ones adjacent: use a max-heap of counts and a single “cooldown/hold” slot for the last used item; each step takes the most frequent available item, re-enqueues the previous one if it still has remaining count.