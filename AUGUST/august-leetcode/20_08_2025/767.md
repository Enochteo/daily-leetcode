## Reorganize String
**Understand**
Given a string s, rearrange its letters so that no two adjacent characters are the same. If it’s impossible, return "".

Key constraint: if any character’s count exceeds (len(s)+1)//2, rearrangement is impossible.

**Match**
Greedy with a max-heap (by frequency). Always place the currently most frequent available character, while keeping the previously used character “on hold” until the next step so it doesn’t repeat.

**Plan**
Count frequencies; early-impossible check with maxCount > (n+1)//2.

Build a max-heap via negative counts.

Keep a prev tuple for the character used in the last step with its remaining count.

Each iteration:

Pop the top (cnt, ch), append ch to result.

If prev still has remaining count, push it back.

Decrement current count and set it as new prev.

When heap is empty, return the built string.