## Task Scheduler
**Understand**
You are given a list of tasks (uppercase letters) and a non-negative cooldown n. Each identical task must be separated by at least n time units. In one time unit you can either execute one task (if available) or be idle. Return the minimum total time units to finish all tasks.

**Match**
Greedy simulation with a max-heap to always pick the most frequent available task, plus a queue to track tasks in cooldown and when they become available again.
Alternative closed-form approach uses count of most frequent tasks, but the heap simulation is straightforward and general.

**Plan**

Count frequencies of tasks.

Push negative counts into a max-heap (Python min-heap with negatives).

Maintain a queue of pairs (remaining_count, ready_time) for tasks cooling down.

For each time step:

Increment time.

If heap not empty, pop a task, execute once (increment the popped negative count by +1 toward zero).

If that task still has remaining count, enqueue it with ready_time = time + n + 1.

Move any tasks from cooldown queue back to the heap when ready_time == time.

When both heap and queue are empty, return time.

**Implement**
```py
import heapq
from collections import Counter, deque

class Solution(object):
    def leastInterval(self, tasks, n):
        """
        :type tasks: List[str]
        :type n: int
        :rtype: int
        """
        freq = Counter(tasks)
        maxHeap = [-cnt for cnt in freq.values()]
        heapq.heapify(maxHeap)

        time = 0
        cooldown = deque()  # (neg_remaining_count, ready_time)

        while maxHeap or cooldown:
            time += 1

            if maxHeap:
                neg_cnt = heapq.heappop(maxHeap)
                neg_cnt += 1  # executed once (toward zero)
                if neg_cnt < 0:
                    cooldown.append((neg_cnt, time + n + 1))

            # move any tasks whose cooldown finished back to heap
            while cooldown and cooldown[0][1] == time:
                heapq.heappush(maxHeap, cooldown.popleft()[0])

            # if heap empty but cooldown not yet ready, loop will idle naturally

        return time
```
**Review**

Uses time + n + 1 as the next valid time for the same task (must wait n full slots before it can be scheduled again).

The inner while returns all tasks that become available at the current time.

Correctly accounts for idle periods when the heap is empty and we are waiting for cooldown.

**Evaluate**
Time Complexity: O(T log K), where T = number of tasks and K = distinct task types.
Space Complexity: O(K) for heap and cooldown queue.
Alternative: Mathematical formula using the maximum frequency maxf and count of tasks with that frequency; runs in O(T), but the heap method is simpler to derive and extend (e.g., varied cooldowns).