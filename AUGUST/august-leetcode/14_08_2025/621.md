## Task Scheduler
**Understand**
You are given a list of tasks (uppercase letters) and a non-negative cooldown n. Each identical task must be separated by at least n time units. In one time unit you can either execute one task (if available) or be idle. Return the minimum total time units to finish all tasks.

**Match**
Greedy simulation with a max-heap to always pick the most frequent available task, plus a queue to track tasks in cooldown and when they become available again.
Alternative closed-form approach uses count of most frequent tasks, but the heap simulation is straightforward and general.

**Plan**

Count frequencies of tasks.

Push negative counts into a max-heap (Python min-heap with negatives).

Maintain a queue of pairs (remaining_count, ready_time) for tasks cooling down.

For each time step:

Increment time.

If heap not empty, pop a task, execute once (increment the popped negative count by +1 toward zero).

If that task still has remaining count, enqueue it with ready_time = time + n + 1.

Move any tasks from cooldown queue back to the heap when ready_time == time.

When both heap and queue are empty, return time.