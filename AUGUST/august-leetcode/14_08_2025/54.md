## Spiral Matrix
**Understand**
Given an m x n matrix, return all elements in spiral order starting at the top-left: go right across the top row, down the right column, left across the bottom row, and up the left column, then repeat for inner layers until all elements are visited. Handle rectangular matrices and edge cases like single row/column and empty input.

**Match**
Matrix boundary traversal using four pointers: top, bottom, left, right. After each directional sweep, shrink the corresponding boundary.

**Plan**

If matrix is empty or matrix[0] is empty, return [].

Initialize top = 0, bottom = m - 1, left = 0, right = n - 1.

While top <= bottom and left <= right:

Traverse left→right across top, then top += 1.

Traverse top→bottom down right, then right -= 1.

If top <= bottom, traverse right→left across bottom, then bottom -= 1.

If left <= right, traverse bottom→top up left, then left += 1.

Return the collected list.

**Implement**
```py
class Solution(object):
    def spiralOrder(self, matrix):
        """
        :type matrix: List[List[int]]
        :rtype: List[int]
        """
        if not matrix or not matrix[0]:
            return []

        res = []
        top, left = 0, 0
        bottom, right = len(matrix) - 1, len(matrix[0]) - 1

        while top <= bottom and left <= right:
            # left to right
            for c in range(left, right + 1):
                res.append(matrix[top][c])
            top += 1

            # top to bottom
            for r in range(top, bottom + 1):
                res.append(matrix[r][right])
            right -= 1

            # right to left
            if top <= bottom:
                for c in range(right, left - 1, -1):
                    res.append(matrix[bottom][c])
                bottom -= 1

            # bottom to top
            if left <= right:
                for r in range(bottom, top - 1, -1):
                    res.append(matrix[r][left])
                left += 1

        return res
```