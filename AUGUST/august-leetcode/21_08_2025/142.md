## Linked List Cycle II

**Understand**
We are given the head of a singly linked list. If the list has a cycle, return the node where the cycle begins; otherwise, return None.

Key fact: If a cycle exists, the point where slow and fast pointers meet is guaranteed to be inside the cycle. The start of the cycle can be found by resetting one pointer to the head and moving both one step at a time until they meet.

**Match**
This is the classic Floyd’s Tortoise–Hare cycle detection problem:

Phase 1 – Detect if a cycle exists.

Phase 2 – Find the cycle’s entry point.

**Plan**

Edge case: If the list is empty, return None.

Use two pointers (slow, fast) initialized at head.

Move slow by 1 and fast by 2 until they meet, or until fast reaches the end (no cycle).

If no cycle, return None.

If they meet, initialize one pointer at head and the other at the meeting point.

Move both one step at a time until they meet again.

The meeting node is the cycle’s entry.

The math: The distance from the head to cycle start = distance from meeting point to cycle start (mod cycle length).

**Implement**
```py
class Solution(object):
    def detectCycle(self, head):
        """
        :type head: ListNode
        :rtype: ListNode
        """
        if not head:
            return
        slow = fast = head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
            if slow == fast:
                break
        else:
            return
        ptr1 = head
        ptr2 = slow
        while ptr1 != ptr2:
            ptr1 = ptr1.next
            ptr2 = ptr2.next
        return ptr1
```