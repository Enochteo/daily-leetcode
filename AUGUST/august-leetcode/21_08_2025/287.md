## Find the Duplicate Number
**Understand**
We are given an array nums of length n+1 containing integers in [1..n]. Exactly one integer is repeated at least once. We must return the duplicate without modifying the array, in O(1) extra space and with better than O(n²) runtime.

By treating the array as a linked list (i → nums[i]), the duplicate value causes a cycle. The task reduces to finding the entry point of the cycle.

**Match**

Floyd’s Tortoise–Hare algorithm for cycle detection.

Phase 1: detect intersection inside the cycle.

Phase 2: find the cycle’s entry point (duplicate number).

**Plan**

Initialize slow = fast = nums[0].

Phase 1: Move slow = nums[slow] and fast = nums[nums[fast]] until they meet → intersection inside the cycle.

Phase 2: Start one pointer at nums[0] and keep the other at the intersection. Move both one step at a time until they meet.

The meeting point is the cycle entry = duplicate number.

Key property: The distance from the start to the cycle entry = distance from the intersection point to the cycle entry. This ensures that when both move one step at a time, they meet at the duplicate.

**Implement**
```py
class Solution(object):
    def findDuplicate(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        slow = fast = nums[0]
        # Phase 1: find intersection
        while True:
            slow = nums[slow]
            fast = nums[nums[fast]]
            if slow == fast:
                break

        # Phase 2: find cycle start (duplicate)
        start = nums[0]
        end = slow
        while start != end:
            start = nums[start]
            end = nums[end]
        return end
```