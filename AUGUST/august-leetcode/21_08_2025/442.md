## Find All Duplicates in an Array
**Understand**
We are given an integer array nums of length n, where each element is in the range [1, n]. Some numbers appear once, others appear twice. Return all numbers that appear twice, in any order.

Constraints: O(n) time, O(1) extra space (ignoring output).

**Match**
Classic index marking trick. Since values are in [1, n], map each value v to index v-1. Negate the element at that index to mark that v has been seen. If we encounter a value whose index target is already negative, then v has been seen before → duplicate.

**Plan**

Initialize res = [].

Iterate i over all indices:

Compute idx = abs(nums[i]) - 1.

If nums[idx] < 0, then abs(nums[i]) is a duplicate → append to result.

Otherwise, flip sign: nums[idx] *= -1.

Return res.

**Implement**
```py
class Solution(object):
    def findDuplicates(self, nums):
        """
        :type nums: List[int]
        :rtype: List[int]
        """
        res = []
        n = len(nums)
        for i in range(n):
            idx = abs(nums[i]) - 1
            if nums[idx] < 0:
                res.append(abs(nums[i]))
            else:
                nums[idx] *= -1
        return res
```
**Review**

Works because every value maps to a valid index in [0..n-1].

Using abs(nums[i]) ensures correctness even if the number was negated in a previous step.

Each duplicate is appended exactly once when we find its index already negative.

**Evaluate**

Time Complexity: O(n)

Space Complexity: O(1) extra (not counting output list).

Modifies nums during execution, but problem allows it.