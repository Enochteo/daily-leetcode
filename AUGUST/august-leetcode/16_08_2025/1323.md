## Maximum 69 Number
**Understand**
You’re given a positive integer num consisting only of digits 6 and 9. You may change at most one digit 6 to 9. Return the maximum possible value after at most one change. If there’s no 6, return num unchanged.

**Match**
Greedy + digit scan. The optimal move is to flip the most significant 6 to 9, since increasing a higher place yields the largest gain.

**Plan**
Scan digits to find the index of the most significant 6, then add 3 * 10^index to num (since 9 - 6 = 3).

Work left-to-right (string) to find first 6, or

Work right-to-left (integer arithmetic), remembering the highest index where a 6 occurs.

**Implement**
```py
class Solution(object):
    def maximum69Number(self, num):
        """
        :type num: int
        :rtype: int
        """
        # Arithmetic approach, works for any length:
        n = num
        pos = -1       # position of most significant 6 (0 = ones place)
        i = 0
        while n > 0:
            if n % 10 == 6:
                pos = i
            n //= 10
            i += 1

        if pos == -1:
            return num  # no 6 to flip

        return num + 3 * (10 ** pos)
```