## Minimum Absolute Difference in BST
**Understand**
You're given the root of a Binary Search Tree (BST).
Find the minimum absolute difference between values of any two nodes in the tree.

Constraints:

All values are unique.

Must take advantage of BST properties if possible.

Must return the minimum absolute difference between any pair of nodes.

**Match**
Applies to:

Binary Search Trees

Difference minimization

In-order traversal or DFS-based comparisons

Your approach:

For each node:

Compare the node's value to the max value in the left subtree

Compare it to the min value in the right subtree

Take the minimum of those and recurse

**Plan**
Define a recursive dfs(node):

If node is None, return a large number (sentinel for min)

If node is a leaf, return large number

Recursively compute:

Difference between node and max of left subtree

Difference between node and min of right subtree

Result of dfs(left) and dfs(right)

Return the minimum of these

get_max(node):

Go as far right as possible in the subtree to find the maximum.

get_min(node):

Go as far left as possible in the subtree to find the minimum.

**Implement**
```python
class Solution(object):
    def getMinimumDifference(self, root):
        def dfs(node):
            if not node:
                return 10**6
            if not node.left and not node.right:
                return 10**6
            return min(
                abs(node.val - get_max(node.left)) if node.left else 10**6,
                abs(node.val - get_min(node.right)) if node.right else 10**6,
                dfs(node.left),
                dfs(node.right)
            )

        def get_max(node):
            curr = node
            while curr.right:
                curr = curr.right
            return curr.val

        def get_min(node):
            curr = node
            while curr.left:
                curr = curr.left
            return curr.val

        return dfs(root)
```

**Review**
Works correctly and handles edge cases (nulls, leaves).

Efficient but does not fully exploit in-order BST traversal properties (see below).

**Evaluate**
Time Complexity:
Worst case: O(nÂ²) in an unbalanced tree
Because get_max and get_min run O(h) per node in recursion

Space Complexity:
O(h) due to recursive stack (height of tree)
