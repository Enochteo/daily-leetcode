## Course Schedule II
**Understand**
You are given numCourses and a list of prerequisites (pairs [a, b] meaning to take course a, you must first take course b).

Goal:
Return a valid order to complete all courses, or an empty list if impossible.

**Match**
This is a Topological Sort problem:

Directed graph

Cycle detection needed (if there's a cycle, return [])

DFS-based post-order traversal can generate the topological order

**Plan**
Build adjacency list:
course_map[course] = [prerequisite1, prerequisite2, ...]

Use dfs(course) to:

Detect cycles using a path set

Track completed nodes in visited

Append nodes to result list (res) after all prerequisites are resolved (post-order)

If a cycle is detected, return [].
Otherwise, return the reverse of the result list.

**Implement**
```python
class Solution(object):
    def findOrder(self, numCourses, prerequisites):
        course_map = {i: [] for i in range(numCourses)}
        for course, prereq in prerequisites:
            course_map[course].append(prereq)

        visited = set()
        path = set()
        res = []

        def dfs(course):
            if course in path:
                return False  # Cycle found
            if course in visited:
                return True   # Already processed

            path.add(course)
            for pre in course_map[course]:
                if not dfs(pre):
                    return False
            path.remove(course)
            visited.add(course)
            res.append(course)
            return True

        for i in range(numCourses):
            if not dfs(i):
                return []
        return res
```

**Review**
Correctly builds topological order

Detects cycles using path set

Appends course after all its prerequisites are resolved

**Evaluate**
Time Complexity: O(V + E)
Where V = numCourses, E = number of prerequisites

Space Complexity: O(V + E)

Adjacency list: O(E)

Visited/path sets + recursion stack: O(V)
