## Simplify Path
**Understand**
Given an absolute Unix-style path string, simplify it:

. means current directory (ignore).

.. means go up one directory (pop stack if not empty).

Multiple slashes / are treated as a single slash.

Result must be a canonical path starting with /, without trailing /, except root.

**Match**
Stack-based parsing. Traverse the path, splitting into components by /:

If .. → pop stack if not empty.

If . or empty → skip.

Else → push directory name.

**Plan**

Append '/' at end so last component is processed uniformly.

Initialize stack = [] and dire = "".

Traverse each char in path:

If / is found: process dire.

If dire == "..": pop if stack non-empty.

Else if dire != "." and not empty: push dire.

Reset dire = "".

Else accumulate char into dire.

After loop, join stack with '/'.

Return '/' + '/'.join(stack).

**Implement**
```py
class Solution:
    def simplifyPath(self, path: str) -> str:
        path += '/'
        stack = []
        dire = ''

        for c in path:
            if c == '/':
                if dire == '..':
                    if stack: 
                        stack.pop()
                elif dire != '.' and dire != '':
                    stack.append(dire)
                dire = ''
            else:
                dire += c
        return '/' + '/'.join(stack)
```

**Review**

Appending '/' ensures the final component is processed.

Handles consecutive slashes: dire will be empty so nothing is pushed.

Correctly resolves . and ...

If stack is empty, returns root /.