## Reverse Linked List II
**Understand**
Given the head of a singly linked list and two positions left and right (1-indexed), reverse the list nodes from position left to right. Return the modified list.

Constraints: must do it in one pass, in-place.

**Match**
Linked list sublist reversal. Use:

A dummy node to simplify edge cases.

Iteration to advance to node before left.

Reverse exactly right-left+1 nodes.

Reconnect the reversed sublist with the rest of the list.

**Plan**

Create dummy = ListNode(0, head) to handle reversing from the head.

Move prev pointer left-1 steps so that it points to the node before the reversal segment.

start = prev.next â†’ first node of the segment to reverse.

Reverse the next right-left+1 nodes using a helper.

reverse(node, count) returns (new_head, remainder) where new_head is the head of the reversed segment and remainder is the node after it.

Reconnect:

prev.next = new_head

start.next = remainder

Return dummy.next as the new head.

**Implement**
```py
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reverseBetween(self, head: Optional[ListNode], left: int, right: int) -> Optional[ListNode]:
        # store initial head
        # loop till left - 1
        # use another function for reverse
        # reverse from head till right also with loop
        # return head
        def reverse(node, end):
            prev = None
            curr = node
            for _ in range(end):
                next_ = curr.next
                curr.next = prev
                prev = curr
                curr = next_
            return prev, curr

        dummy = ListNode(0, head)
        prev = dummy
        for _ in range(left - 1):
            prev = prev.next
        start = prev.next
        new_head, unreversed = reverse(start, right - left + 1)
        prev.next = new_head
        start.next = unreversed
        return dummy.next
```