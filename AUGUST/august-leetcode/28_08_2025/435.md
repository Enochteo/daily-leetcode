## Non-overlapping Intervals
**Understand**
Given a set of intervals, remove the minimum number of intervals so that the rest are non-overlapping. Return the minimum removals.

Key idea: To keep as many intervals as possible (and thus remove as few), prefer intervals that finish earliest.

**Match**
Greedy scheduling (activity selection): sort by end time and keep a running “previous kept” interval. If the next interval starts before the previous end, it overlaps → increment removals; otherwise, accept it and advance the previous pointer.

**Plan**

Sort intervals by their end time.

Initialize prev to the first interval and removals = 0.

For each subsequent interval (start, end):

If start < prev.end, it overlaps → removals += 1.

Else, set prev = current (accept it).

Return removals.

**Implement**
```py
class Solution:
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:
        removals = 0
        intervals.sort(key = lambda x: x[1])
        prev = intervals[0]
        for i, (start, _) in enumerate(intervals):
            if i == 0:
                continue
            if start < prev[1]:
                removals += 1
            else:
                prev = intervals[i]
            #print(prev)
        return removals
```