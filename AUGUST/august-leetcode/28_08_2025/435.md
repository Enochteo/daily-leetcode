## Non-overlapping Intervals
**Understand**
Given a set of intervals, remove the minimum number of intervals so that the rest are non-overlapping. Return the minimum removals.

Key idea: To keep as many intervals as possible (and thus remove as few), prefer intervals that finish earliest.

**Match**
Greedy scheduling (activity selection): sort by end time and keep a running “previous kept” interval. If the next interval starts before the previous end, it overlaps → increment removals; otherwise, accept it and advance the previous pointer.

**Plan**

Sort intervals by their end time.

Initialize prev to the first interval and removals = 0.

For each subsequent interval (start, end):

If start < prev.end, it overlaps → removals += 1.

Else, set prev = current (accept it).

Return removals.