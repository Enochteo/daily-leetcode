## Jump Game
**Understand**
Given an array nums where nums[i] is the maximum jump length from index i, return True if you can reach the last index starting from index 0.

Examples:

[2,3,1,1,4] → True (0→1→4).

[3,2,1,0,4] → False (stuck at index 3).

**Match**
Greedy algorithm: as you traverse, keep track of the farthest reachable index. If at any index i, farthest < i, then you’re stuck → return False. Otherwise, expand reach with farthest = max(farthest, i + nums[i]).

**Plan**

Initialize farthest = 0.

Traverse i from 0 to n-1:

If i > farthest, return False.

Update farthest = max(farthest, i + nums[i]).

If loop finishes, return True.

**Implement**
```py
class Solution:
    def canJump(self, nums: List[int]) -> bool:
        farthest = 0
        for i in range(len(nums)):
            if farthest < i:
                return False
            farthest = max(farthest, i + nums[i])
        return True
```

**Review**

Works for all edge cases:

Single element array → trivially True.

Arrays with zeroes handled by stuck check.

Early exit occurs naturally if you get stuck.

**Evaluate**

Time Complexity: O(n)

Space Complexity: O(1)