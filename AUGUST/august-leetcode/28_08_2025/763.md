## Partition Labels
**Understand**
We are given a string s. Partition it into as many parts as possible so that each letter appears in at most one part. Return a list of partition sizes.

Example:
s = "ababcbacadefegdehijhklij" → [9,7,8].

Key: Each partition boundary occurs when all characters in the current window have their last occurrence inside that window.

**Match**
Greedy strategy:

Precompute last occurrence index of each character.

Expand a window starting at position r.

While scanning inside the window, extend it if you encounter a character whose last occurrence goes further.

Once index reaches window’s end, record partition size and start a new window.

**Plan**

Precompute last_occurrences[c] = index for all characters.

Initialize r = 0.

While r < len(s):

Set window_size = last_occurrences[s[r]] - r + 1.

Scan indices in [r+1, r+window_size):

If last_occurrences[s[i]] extends beyond current window, enlarge window_size.

Append window_size to result.

Update r += window_size.

Return result list.

**Implement**
```py
class Solution:
    def partitionLabels(self, s: str) -> List[int]:
        res = []
        last_occurences = {}
        for i, c in enumerate(s):
            last_occurences[c] = i
        r = 0
        while r < len(s):
            window_size = last_occurences[s[r]] - r + 1
            index = r + 1
            while index < (r + window_size):
                window_size = max(window_size, last_occurences[s[index]] - r + 1)
                index += 1
            res.append(window_size)
            r += window_size 
        return res
```