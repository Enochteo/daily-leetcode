## Rotate Image - Intuitive (Lazy Approach)
**Understand**
Given an n x n matrix, rotate it 90 degrees clockwise in-place (modify the input without allocating another n x n matrix).

**Match**
Matrix transforms:

Transpose (swap across main diagonal), then

Reverse each row.
This composes to a 90° clockwise rotation.

**Plan**
Intuitive approach
Let n = len(matrix).

In-place transpose: for each r in [0..n-1] and c in [r+1..n-1], swap matrix[r][c] with matrix[c][r].

Reverse each row in-place.

Done.

**Implement**
```py
class Solution(object):
    def rotate(self, matrix):
        """
        :type matrix: List[List[int]]
        :rtype: None
        """
        n = len(matrix)
        # transpose
        for r in range(n):
            for c in range(r + 1, n):
                matrix[r][c], matrix[c][r] = matrix[c][r], matrix[r][c]
        # reverse each row
        for r in range(n):
            matrix[r] = matrix[r][::-1]
```

**Review**

Transpose swaps (r, c) with (c, r) once by iterating c from r+1, avoiding double swaps and self-swaps.

Reversing each row after transpose achieves the desired rotation without extra O(n^2) storage.

Assumes square matrix as per problem constraints.

**Evaluate**
Time Complexity: O(n^2).
Space Complexity: O(1) auxiliary.
Alternative: Layer-by-layer 4-way cyclic swaps (top→right→bottom→left), also O(n^2)/O(1), slightly more intricate but avoids the two-pass structure.

**Pattern to remember**
To rotate a square matrix 90° clockwise in-place: Transpose, then reverse each row.
For 90° counterclockwise: Transpose, then reverse each column.