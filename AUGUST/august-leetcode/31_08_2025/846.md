## Hand of Straights
**Understand**
We’re given an integer array hand and a group size groupSize. We must check if it’s possible to rearrange hand into groups of size groupSize where each group is a sequence of consecutive cards.

Example:

hand = [1,2,3,6,2,3,4,7,8], groupSize = 3 → True
(groups = [1,2,3], [2,3,4], [6,7,8])

**Match**
Greedy with frequency counts:

Sort the hand so we always try to build from the smallest card.

Use a counter to track how many of each card remain.

For each card in sorted order, if its count > 0, attempt to build a full group [card, card+1, ..., card+groupSize-1].

If any card in the required group is missing or exhausted, return False.

**Plan**

Sort the hand.

Build a Counter(hand) for card frequencies.

Iterate through sorted hand:

If counts[start] == 0, continue.

Otherwise, for j in [0..groupSize-1]:

Check if counts[start+j] > 0.

If not, return False.

Else, decrement it.

If loop completes, return True.

**Implement**
```py
class Solution:
    def isNStraightHand(self, hand: List[int], groupSize: int) -> bool:
        hand.sort()
        counts = Counter(hand)

        for i in range(len(hand)):
            start = hand[i]
            if counts[start] == 0:
                continue
            for j in range(groupSize):
                if counts[start + j] == 0:
                    return False
                counts[start + j] -= 1
        return True
```

**Review**

Sorting ensures we always build from the lowest available card.

Using if start+j not in hand is unnecessary, since Counter will return 0 if a key is missing; checking counts[start+j] == 0 is sufficient.

Works correctly but may be less efficient because we scan hand rather than just keys of the counter.

**Evaluate**

Time Complexity: O(n log n) for sorting + O(n·groupSize) for forming groups.

Space Complexity: O(n) for the counter.

**Pattern to remember**
For problems requiring grouping into consecutive sequences:

Sort the items.

Use a frequency counter.

Greedily form sequences starting from the smallest available item, decrementing counts, and fail if any required element is missing