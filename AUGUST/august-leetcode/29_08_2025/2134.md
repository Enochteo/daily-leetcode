## Minimum Swaps to Group All 1’s Together II

**Understand**
We want to group all the 1s in a binary circular array with minimum swaps. Equivalent: find the maximum number of 1s that can already fit into a contiguous window of length ones = total number of 1s. Then the number of swaps needed = ones - max_ones_in_window.

Because the array is circular, extend nums by concatenating it with itself and scan windows of size ones across length n.

**Match**
Sliding window over doubled array. Keep track of how many 1’s in the current window, update max, then compute result.

**Plan**

Compute ones = sum(nums) = total number of 1s.

Extend array: nums = nums + nums.

Initialize window sum as sum(nums[:ones]).

Slide the window from ones to ones+n-1:

Add new element, subtract element leaving the window.

Update max_ones = max(max_ones, window).

Return ones - max_ones.

**Implement**
```py
class Solution(object):
    def minSwaps(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        n = len(nums)
        ones = sum(nums)
        nums = nums + nums
        window = sum(nums[:ones])
        max_ones = window
        l = 0
        for r in range(ones, ones + n):
            window += nums[r] - nums[r - ones]
            max_ones = max(max_ones, window)
        return ones - max_ones
```

**Review**

Works because we only need to consider windows of length equal to total ones.

Doubling handles circular adjacency.

Result is minimal swaps required to bring all 1’s together.