## Minimum Operations to Make Binary Array All Ones (flip 3 consecutive)

**Understand**
Given a binary array nums, in one operation you may flip (toggle 0↔1) a block of three consecutive elements starting at index i: positions i, i+1, i+2. Return the minimum number of operations to turn the entire array into all 1s, or -1 if impossible.

**Match**
Greedy sweep from left to right. Whenever you see a 0 at position i, you must flip the window starting at i (it’s the only way to fix nums[i]), so toggle i, i+1, i+2 and increment the count. After processing up to n-3, check the tail; if any 0 remains, it’s impossible.

**Plan**

Initialize swaps = 0.

For i = 0 .. n-3:

If nums[i] == 0, flip nums[i], nums[i+1], nums[i+2] (toggle with XOR 1) and increment swaps.

After the loop, if all entries are 1, return swaps; otherwise return -1.

**Implement**
```py
class Solution(object):
    def minOperations(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        swaps = 0
        for i in range(len(nums)-2):
            if nums[i] == 0:
                for j in range(3):
                    nums[i + j] = nums[i + j] ^ 1
                swaps += 1
        return swaps if sum(nums) == len(nums) else -1
```

**Review**

Flipping when you see a 0 at i is necessary and never hurts later decisions (standard local-greedy for fixed-size window).

Final check ensures the last two positions (which can no longer be flipped by starting at n-2 or n-1) are already 1.

**Evaluate**

Time Complexity: O(n).

Space Complexity: O(1) auxiliary (modifies input in-place).

**Pattern to remember**
When operations flip a fixed-size window and you need a uniform target (all 1s/0s), sweep left→right: if the current bit is wrong, apply the only window that can fix it; at the end, verify the tail for feasibility.