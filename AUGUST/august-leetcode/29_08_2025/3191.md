## Minimum Operations to Make Binary Array All Ones (flip 3 consecutive)

**Understand**
Given a binary array nums, in one operation you may flip (toggle 0↔1) a block of three consecutive elements starting at index i: positions i, i+1, i+2. Return the minimum number of operations to turn the entire array into all 1s, or -1 if impossible.

**Match**
Greedy sweep from left to right. Whenever you see a 0 at position i, you must flip the window starting at i (it’s the only way to fix nums[i]), so toggle i, i+1, i+2 and increment the count. After processing up to n-3, check the tail; if any 0 remains, it’s impossible.

**Plan**

Initialize swaps = 0.

For i = 0 .. n-3:

If nums[i] == 0, flip nums[i], nums[i+1], nums[i+2] (toggle with XOR 1) and increment swaps.

After the loop, if all entries are 1, return swaps; otherwise return -1.