## Valid Parenthesis String
**Understand**
Given a string s containing '(', ')', and '*':

'*' can represent '(', ')', or an empty string.
Return whether s can be a valid parenthesis string.

Constraints: balanced parentheses with flexible use of *.

**Match**
Greedy + stack indices:

Track indices of `'('` and `'*'`.

When encountering `')'`, try to match with `'('` first, else with '*'.

After scan, some `'('` may remain unmatched. Use available '*' after them (treat as `')'`).

If any `'('` has no later `'*'`, invalid.

**Plan**

Initialize two stacks:

open_stack: indices of `'('`.

stars: indices of `'*'`.

Iterate string:

`'('` → push index to open_stack.

`'*'` → push index to stars.

`')'` → pop from open_stack if available, else from stars, else invalid → return False.

After iteration:

While both open_stack and stars non-empty, check ordering. If the `'*'` index is after the `'('` index, pop both (valid). If not, invalid.

Return True if open_stack is empty, else False.

**Implement**
```py
class Solution(object):
    def checkValidString(self, s):
        """
        :type s: str
        :rtype: bool
        """
        open_stack = []
        stars = []
        for i in range(len(s)):
            if s[i] == '(':
                open_stack.append(i)
            elif s[i] == '*':
                stars.append(i)
            else:
                if not open_stack and not stars:
                    return False
                if open_stack:
                    open_stack.pop()
                else:
                    stars.pop()
        while stars and open_stack:
            if stars.pop() < open_stack.pop():
                return False
        return not open_stack
```

**Review**

Matches `')'` greedily with `'('` first to maximize balanced structure.

Final cleanup ensures `'*'` positions occur after unmatched `'('` (since they must act as `')'`).

Returns True only when all `'('` are matched.

**Evaluate**

Time Complexity: O(n).

Space Complexity: O(n) in worst case (all characters go into stacks).

Alternative approach: Greedy with two counters (lo, hi) that track the min/max possible open parentheses count, reducing space to O(1).