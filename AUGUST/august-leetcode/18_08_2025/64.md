## Minimum Path Sum
**Understand**
Given an m x n grid of non-negative integers, starting at the top-left, move only right or down to reach the bottom-right. Return the minimal path sum.

**Match**
Dynamic Programming with rolling array (1D). At cell (r, c), the minimal cost is grid[r][c] + min(from_top, from_left).

**Plan**
Maintain a 1D array dp[c] representing the minimal path sum to the current row’s column c.

Initialize dp = [inf]*n, set dp[0] = 0 and accumulate the first column as you iterate rows.

For each cell, update dp[c] = grid[r][c] + min(dp[c] (from top), dp[c-1] (from left)).

Answer is dp[n-1].

**Implement**
```py
class Solution(object):
    def minPathSum(self, grid):
        """
        :type grid: List[List[int]]
        :rtype: int
        """
        rows = len(grid)
        cols = len(grid[0])
        dp = [float('inf')] * cols
        dp[0] = 0
        for r in range(rows):
            dp[0] += grid[r][0]
            for c in range(1, cols):
                if c == 0:
                    continue
                dp[c] = grid[r][c] + min(dp[c], dp[c-1])
        return dp[cols-1]
```

**Review**

dp[c] before update holds the minimal cost to reach (r-1, c) (from top).

dp[c-1] holds the cost to reach (r, c-1) (from left).

The loop accumulates the first column incrementally and then updates across columns left→right per row.