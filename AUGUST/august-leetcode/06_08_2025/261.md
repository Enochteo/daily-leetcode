## Graph Valid Tree
**Understand**
You're given:

An integer n (number of nodes labeled 0 to n-1)

A list of edges

Goal:
Return True if the given edges form a valid tree (acyclic and connected), else False.

**Match**
This is a graph validation problem.

Tree Properties:

Must be connected (all nodes reachable)

Must be acyclic (no cycles)

Must have exactly n - 1 edges (key property of a tree)

**Plan**
Early check: If number of edges ≠ n - 1, it's not a tree.

Build an adjacency list.

Use DFS:

Traverse nodes and track visited nodes

Avoid going back to the parent

If you revisit any node that's already visited (excluding the parent), it's a cycle

After DFS:

Check if all n nodes were visited (i.e., graph is connected)

**Implement**
```python
from collections import defaultdict

class Solution:
    def validTree(self, n: int, edges: List[List[int]]) -> bool:
        if len(edges) != n - 1:
            return False

        graph_map = defaultdict(list)
        visited = set()

        for u, v in edges:
            graph_map[u].append(v)
            graph_map[v].append(u)

        def dfs(node, parent):
            visited.add(node)
            for neighbor in graph_map[node]:
                if neighbor == parent:
                    continue
                if neighbor in visited:
                    return False
                if not dfs(neighbor, node):
                    return False
            return True

        return dfs(0, -1) and len(visited) == n
```

**Review**
 DFS correctly checks for cycles

 Uses early edge-count pruning

 Verifies full connectivity using visited set

Adjacency list constructed properly

**Evaluate**
Time Complexity: O(n + e) = O(n) since e = n - 1

Space Complexity: O(n) for the graph and visited set

Efficient and clean — this is an ideal DFS-based solution for checking if an undirected graph is a valid tree.