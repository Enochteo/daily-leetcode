## Partition Equal Subset Sum
**Understand**
We’re given an array nums. We need to decide if it can be partitioned into two subsets with equal sum.
Equivalent to: can we find a subset whose sum = total // 2? (only possible if total is even).

**Match**
DFS with memoization:

At each index i, try putting nums[i] in setA or in setB.

Use a memo dictionary to avoid recomputing the same (i, setA, setB) state.

Base case: if i == len(nums), return whether setA == setB.This works but is inefficient because state grows large.
Optimal: reduce to subset sum problem → 0/1 knapsack style DP.

**Plan** (subset sum)

Initialize a memo dictionary for caching results.

Define recursive function dfs(i, setA, setB):

If (i, setA, setB) seen, return memoized result.

If i == len(nums), return whether setA == setB.

Otherwise, branch:

Add nums[i] to setA, recurse.

Or add nums[i] to setB, recurse.

Store result in memo and return.

Call dfs(0, 0, 0) as entry point.


**Implement**
```py
class Solution(object):
    def canPartition(self, nums):
        """
        :type nums: List[int]
        :rtype: bool
        """
        memo = {}
        def dfs(i, setA, setB):
            if (i, setA, setB) in memo:
                return memo[(i, setA, setB)]
            if i == len(nums):
                if setA == setB:
                    return True
                else:
                    return False
            res = dfs(i+1, setA + nums[i], setB) or dfs(i+1, setA, setB + nums[i])
            memo[(i, setA, setB)] = res
            return res
```