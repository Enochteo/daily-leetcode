## Word Search
**Understand**
Given an m x n board of characters and a word, determine if the word exists in the grid by sequentially adjacent cells (up, down, left, right). You may not reuse a cell within the same path.

**Match**
Depth-first search with backtracking. Track a visited set to prevent revisiting cells on the current path.

**Plan**

For each cell as a starting point, attempt to match word via DFS.

At DFS (i, j, k), success if k == len(word).

Fail fast if out of bounds, already visited, or char mismatch.

Mark (i, j) visited, recurse into four neighbors with k+1, then unmark (backtrack).

If any start succeeds, return True; otherwise False.

**Implement**
```py
class Solution:
    def exist(self, board: List[List[str]], word: str) -> bool:
        # backtracking problem
        # track each index with k and the matrix with i, j
        # if they dont match we backtrack
        # if k ends k == len(word) then they match
        rows = len(board)
        cols = len(board[0])
        visited = set()
        def backtrack(i, j, k):
            if k == len(word):
                return True
            if min(i, j) < 0 or i>=rows or j>=cols or (i, j) in visited or board[i][j] != word[k]:
                return False
            visited.add((i, j))
            res = backtrack(i+1, j, k+1) or backtrack(i, j+1, k+1) or backtrack(i-1, j, k+1) or backtrack(i, j-1, k+1)
            visited.remove((i, j))
            return res

        for r in range(rows):
            for c in range(cols):
                if backtrack(r, c, 0):
                    return True
        return False
```

**Review**

Tries all starts and explores four directions at each step.

visited ensures a cell is used at most once per current path, then released on backtrack.

Early termination on mismatch or out-of-bounds keeps it efficient in practice.

**Evaluate**
Time Complexity: O(m·n·4^L) in the worst case (L = len(word)), with pruning from mismatches.
Space Complexity: O(L) recursion depth and visited entries along the current path.

**Pattern to remember**
For path-existence in a grid with non-reuse of cells: DFS with backtracking → check bounds and character match, mark visited, explore four neighbors with k+1, unmark on return, and stop when k == len(word).