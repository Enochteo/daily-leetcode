## Minimum Height Trees
**Understand**
Given an undirected graph with n nodes labeled 0..n-1 and edges forming a tree, return all the root labels of Minimum Height Trees (MHTs).
Observation: The root(s) of MHTs are the middle node(s) of the tree’s diameter path.

**Match**
Graph on a tree (connected, acyclic)

Longest path (tree diameter)

BFS on an unweighted graph

Centers of a path (one or two)

**Plan**
Build adjacency list for the tree.

Run BFS from any node (e.g., 0) to find the farthest node A.

Run BFS from A to find the farthest node B and track parents to reconstruct the diameter path A→…→B.

The MHT roots are the middle node(s) of that path:

If path length is odd → one center

If path length is even → two centers

**Implement**
```python
from collections import defaultdict, deque

class Solution(object):
    def findMinHeightTrees(self, n, edges):
        """
        :type n: int
        :type edges: List[List[int]]
        :rtype: List[int]
        """
        if n == 1:
            return [0]

        graph = defaultdict(list)
        for u, v in edges:
            graph[u].append(v)
            graph[v].append(u)

        def bfs(start):
            q = deque([start])
            parents = {start: None}
            visited = {start}
            last = start
            while q:
                node = q.popleft()
                last = node
                for nei in graph[node]:
                    if nei not in visited:
                        visited.add(nei)
                        parents[nei] = node
                        q.append(nei)
            return last, parents  # farthest node from start, and parent map

        # 1) farthest from arbitrary node (0) -> A
        A, _ = bfs(0)
        # 2) farthest from A -> B and parents to reconstruct path
        B, parents = bfs(A)

        # Reconstruct diameter path A -> ... -> B
        path = []
        cur = B
        while cur is not None:
            path.append(cur)
            cur = parents[cur]
        path.reverse()

        m = len(path)
        if m % 2 == 1:
            return [path[m // 2]]
        else:
            return [path[m // 2 - 1], path[m // 2]]
```